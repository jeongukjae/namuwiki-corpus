{
    "namespace": 0,
    "title": "Python",
    "text": "[include(틀:다른 뜻1, other1=다른 의미의 Python, rd1=파이선)]\n[include(틀:프로그래밍 언어)]\n||<table width=100%><-5><bgcolor=deepskyblue><table bordercolor=deepskyblue><table bgcolor=white,#222> '''{{{#white TIOBE 선정 올해의 프로그래밍 언어}}}''' ||\n||<width=28%> 2006년[br][[Ruby]] ||<width=8%> → ||<width=28%> 2007년[br][[Python]] ||<width=8%> → ||<width=28%> 2008년[br][[C언어|C]] ||\n|| 2009년[br][[Go(프로그래밍 언어)|Go]] || → || 2010년[br][[Python]] || → || 2011년[br][[Objective-C]] ||\n|| 2017년[br][[C언어|C]] || → || 2018년[br][[Python]] || → || 2019년[br][[C언어|C]] ||\n|| 2019년[br][[C언어|C]] || → || 2020년[br][[Python]] || → || ''없음'' ||\n\n||<-2><tablealign=right><tablewidth=400> {{{#!wiki style=\"margin: -5px -10px; padding: 5px 10px; background-image: linear-gradient(to right, #3775a9 30%, #ffdc4d 90%)\"\n'''{{{+1 {{{#000,#fff 파이썬}}}}}}'''[br]{{{#000,#fff Python}}}}}} ||\n||<-2> [[파일:python-logo-master-v3-TM.png|width=100%]] ||\n|| 개발 ||파이썬 소프트웨어 재단 (PSF) ||\n|| 버전 ||{{{+1 3.9.2}}}\n2021년 2월 19일 업데이트 ||\n|| 웹사이트 ||[[https://www.python.org/|[[파일:홈페이지 아이콘.png|width=25]]]] ||\n\n\n[목차]\n[clearfix]\n== 개요 ==\n{{{#!syntax python\n# 1\nprint(\"Hello, world!\")\n# 2\nimport __hello__\n# 둘중 하나를 선택해서 사용\n}}}\n위의 문법은 파이썬 3 기준이다. 파이썬 2에서는 print \"Hello, world!\"만 해도 충분하다.\n\n>'''\"Life is short ([[프로그래머|You]] need Python)\"'''[* Python의 엄청나게 빠른 개발 속도와 생산성을 두고 개발자들 사이에서 유행처럼 퍼진 말이다.]\n>'''인생은 짧으니, 당신은 파이썬이 필요하다.'''\n>----\n>- Bruce Eckel\n1991년에 발표된, [[MATLAB]]과 유사한 [[인터프리터]] 방식의 [[프로그래밍 언어]]. [[https://www.python.org/|공식 홈페이지]] [[https://github.com/python/cpython|공식 깃헙 저장소]]\n\n최신 버전은 2020년 12월 07일에 나온 3.9.1 버전이며 0.1버전마다 for문 등의 루프에서 연산 효율이 약 2배 빨라지는 개선이 존재하므로, 최신 버전이 3개월 이상 지나 안정화가 된 후에는 귀찮더라도 버전을 반드시 업데이트 하기를 추천한다.\n\n온라인 상으로 코드를 실행시켜 보고 싶다면 [[https://repl.it/languages/python3?v2=1|여기]]로.[* 여기에서 쓰는 버전은 3.8.2이다]\n\n창시자는 귀도 반 로섬(Guido van Rossum). 1989년 크리스마스 주에, 연구실이 닫혀있어서 '''[[국부론|심심한 김에 만든 프로그래밍 언어이다]].''' 농담이 아니고 반 로섬을 [[유럽]]에서는 [[애덤 스미스]]에 비교할 정도다. 프로그래밍 계의 경제학자라나... 심심해서 만들었다는 것은 [[https://www.python.org/doc/essays/foreword/|파이썬 서문]]과 [[https://www.imaso.co.kr/news/article_view.php?article_idx=20150921073159|마이크로소프트웨어와 한 인터뷰]]를 보면 알겠지만 사실이다. 기술자들은 대부분 [[리눅스|심심할 때]], 혹은 [[드롭박스|실수로]] 걸작을 만든다. 2000년에는 Python 2, 2008년에는 Python 3가 나왔다.\n\n이름은 귀도가 즐겨 보던 영국의 6인조 코미디 그룹 [[몬티 파이선]]에서 따왔다고 한다. 지금 CPython의 공식 [[GitHub]] 저장소를 보면 협업보조용 봇 이름들이 [[https://github.com/the-knights-who-say-ni|the-knights-who-say-ni]]([[니라고 말하는 기사]])나 [[https://github.com/bedevere-bot|bedevere]]([[베디비어]]) 같이 죄다 [[몬티 파이선과 성배]]의 배역들이다. 많은 파이썬 교재들에서 변수 이름을 [[스팸(몬티 파이선 스케치)|spam]], eggs로 짓는 등 드립을 친다. 직접적 관계는 없지만 [[42]]도 필수요소. 또한 시작 프로그램 중 하나의 이름이 아이들(Idle)인데, 탄생배경을 생각해 본다면 몬티 파이선의 멤버 에릭 아이들(Eric Idle)의 이름에서 유래하였을 가능성이 높다. 물론 사전적 의미를 생각 안 하는 건 아니라서 심볼마크가 [[뱀]] 모양이다.\n\n문법이 매우 쉬워서 초보자들이 처음 프로그래밍을 배울 때 추천되는 언어이다. 오죽하면 Python의 별명이 ''''실행할 수 있는 [[의사 코드]](Executable pseudocode)''''일 정도. 실제로도 미국 공과 대학교에서 컴퓨터 프로그래밍 입문 수업으로 Python을 많이 사용하기도 한다. 학습용으로 좋은 언어인 동시에 '''실사용률과 생산성'''도 높은 강력한 언어인 셈. 즉 '''접근성과 응용력이 좋다'''는 게 굉장히 중요하다. --배우기도 쉽고 써먹기도 쉽고-- Python의 이런 두 마리 토끼는 교육용 프로그래밍 언어인 [[BASIC]]이 [[망했어요]] 루트를 타게 된 결정적인 이유이다. Python은 BASIC과 달리 학교에서 배우고 끝나는 게 아니라 현업에서도 자주 쓰이는 언어이기 때문이다. 농담이 아니고 파이썬이 교육용 언어로 자리잡으면서 베이직은 [[마이크로소프트]]에 의해 산소호흡기를 달고 연명만 하는 신세가 됐다. MS가 없으면 [[안습|BASIC은...]]\n\n2010년 후반대에 이르러서는 풍부한 머신러닝 라이브러리와 프레임웍으로 머신러닝, 딥러닝등 인공지능 개발을 위한 언어로서 각광을 받고 있다. 사이킷-런(Scikit-learn), 텐서플로우(TensorFlow), CNTK, 아파치 스파크 MLlib(Apache Spark MLlib), 파이토치(PyTorch)등 성능도 뛰어나며 많이 사용되는 머신러닝, 딥러닝 프레임웍들이 파이썬으로 접근이 가능하다.\n\n파이선은 많은 블록코딩에 사용된다.\n\n원문보기: [[http://www.ciokorea.com/news/38148#csidxf24bb678303a92fa914daf16bfe161f|#]]\n== 특징 ==\n=== 디자인 철학 ===\n[[Perl]]의 '하나 이상의 해결법이 존재한다' 에 대비되는 '가장 아름다운 하나의 답이 존재한다' 를 기본으로 하고 있다. 이것은 남이 작성한 코드를 내가 읽고 이해해야 하는 경우 아주 절실히 느낄 수 있다. 이 점은 Tim Peters가 작성한 파이썬 기본 철학(The Zen of Python)에서 더 자세히 나열되어 있는데, 20가지 항목이라고 표현하고 있지만 실은 19가지 항목만 있는 등 '규칙'보다는 농담도 섞인 '조언'에 가까운 문항들이다. [[https://www.python.org/dev/peps/pep-0020/|#]] 콘솔에서 \"import this\"를 입력하면 [[이스터 에그]]로써 파이썬을 통해 볼 수 있다. dir(this)를 하면 ROT13으로 인코딩된 this.s를 확인할 수 있다. this.d로 dictionary( {} )를 사용해 해독하면 원문이 나온다.\n\n{{{#!folding 【PEP 20 -- The Zen of Python 펼치기 · 접기】\n * 아름다운 것이 추한 것보다 낫다. (Beautiful is better than ugly.)\n * 명시적인 것이 암시적인 것보다 낫다. (Explicit is better than implicit.)\n * 간결한 것이 복합적인 것보다 낫다. (Simple is better than complex.)\n * 복합적인 것이 복잡한 것보다 낫다. (Complex is better than complicated.)\n * 수평적인 것이 내포된 것보다 낫다. (Flat is better than nested.)\n * 여유로운 것이 밀집한 것보다 낫다. (Sparse is better than dense.)\n * 가독성은 중요하다. (Readability counts.)\n * 특별한 경우들은 규칙을 어길정도로 특별하지 않다. (Special cases aren't special enough to break the rules.)\n * 허나 실용성은 순수성을 이긴다. (Although practicality beats purity.)\n * 오류는 절대로 조용히 지나가지 않는다. (Errors should never pass silently.)\n * 명시적으로 오류를 감추려는 의도가 아니라면. (Unless explicitly silenced.)\n * 모호함을 대할때, 이를 추측하려는 유혹을 거부하라. (In the face of ambiguity, refuse the temptation to guess.)\n * 명확한-\\- 그리고 가급적이면 유일한 -\\- 하나의 방법은 항상 존재한다. (There should be one-\\- and preferably only one -\\-obvious way to do it.)\n * 비록 그 방법이 처음에는 명확해 보이지 않을지라도[* 원문에는 \"네덜란드인이 아닌 이상\" 이라는 농담조의 조건이 붙는데, 아마도 파이썬의 창시자인 귀도 반 로섬을 두고 하는 얘기로 보인다.]. (Although that way may not be obvious at first unless you're Dutch.)\n * 지금 행동에 옮기는 것이 아예 안하는 것보다는 낫다. (Now is better than never.)\n * 비록 아예 안하는 것이 지금 *당장* 하는 것보다 나을때도 많지만. (Although never is often better than *right* now.)\n * 구현 결과를 설명하기 쉽지 않다면, 그것은 나쁜 아이디어이다. (If the implementation is hard to explain, it's a bad idea.)\n * 구현 결과를 설명하기 쉽다면, 그것은 좋은 아이디어일지도 모른다. (If the implementation is easy to explain, it may be a good idea.)\n * 네임스페이스를 사용하는 것은 완전 좋은 생각이다! (Namespaces are one honking great idea -- let's do more of those!)}}}\n파이썬의 이런 철학은 이후 다른 프로그래밍 언어들에도 수출되어, [[2010년대]] 들어서는 기존 언어들도 '''파이썬처럼 최대한 문법 구조를 단순화시키고 통일하려는 문법 대통일 운동'''이 일어나기 시작했다. 이는 [[프로그래머]]들이 프로그램을 돌려보기 좋게 한다는 '''매우 좋은 영향'''이 있으니까...\n\n따라서 다른 언어들의 코딩 스타일은 각자의 취향에 맞게 [[발산 진화]]하는 반면, 파이썬은 위의 철학들을 만족 시키는 하나의 스타일로 [[수렴 진화]]하는 성향이 있다. 실제로 C 계열의 언어에서 중괄호의 위치에 대한 논쟁은 거의 종교적 논쟁에 가깝다. 현재 한국에서 가장 많이 쓰이는 방식은 C언어의 창시자 Kernighan과 Ritchie의 K&R 스타일이다. 그러나 Eric Allman의 방식을 고수하는 사람들도 제법 많다. 이외에도 중괄호 위치를 정하는 다른 방법들이 있으며 자세한 내용은 [[http://gyumee.egloos.com/1306012]]에서 확인 가능하다. --그리고 흔치는 않지만 몇몇 사람들은 그냥 들여쓰기고 뭐고 다 무시하고 쭉 작성해놓기도 한다.-- 이런 성향은 다른 언어에는 없는 파이썬스러움('''pythonic''')이라는 독특한 개념을 낳게 되었는데, 복잡하지 않으면서 의미가 명확하고, 코드의 축약보다 뚜렷하게 보이는 흐름을 중시하는 파이썬의 철학을 지칭하는 개념이다.\n\n이런 철학 때문에 문법이 굉장히 엄격한 편이다. 예를 들자면, 다른 언어에서는 해도 되고 안 해도 되는 들여쓰기가 이 언어에서는 의무로, 들여쓰기 자체로 하나의 코드 블럭이 된다. 코드 블럭을 명시적으로 표시하지 않아도 돼서 비주얼 적으로는 굉장히 깔끔한 반면 자유도를 제약한다는 평도 있다. --근데 어차피 들여쓰기는 하게 된다.--\n\n코드에서 중괄호는 모아놓고 보면 굉장히 지저분할 뿐더러, 당장 입력해야 하는 괄호가 2개나 되고,[* 대부분 IDE는 여는 괄호 1개를 입력하면, 자동으로 닫는 괄호를 입력해준다.] 괄호 하나라도 잘못 넣으면 블럭이 다 꼬여버리는 귀찮은 존재이지만(begin과 end 혹은 end.으로 구분해야 하는 파스칼에서 보면 중괄호만 해도 엄청나게 간결해 보이지만), 대신 블럭들을 이리저리 만질때는 매우 편리한 존재이다. 특히 C 코드를 종이에 출력해보면 중괄호 있고 없고의 가독성 차이가 의외로 크다. 파이썬에서는 이 중괄호를 들여쓰기로 대체하는데, 이게 블럭의 시작과 끝 지점을 찾는 부분에서 꽤 불편하다. 대신 괄호를 2개나 일일이 다 넣고, 잘못 넣지 않게 점검도 해 줘야하는 수고가 없다는 엄청난 장점이 있다.\n{{{#!syntax python\ndef factorial(x):\n    if x == 0:\n        return 1\n    else:\n        return x * factorial(x - 1)\n}}}이 들여쓰기 의무 규칙 때문에 소스 코드 들여쓰기에 탭([[Tab]]) 문자를 사용하지 '''않을 것을 매우 강력히 요구한다.'''[* Python의 형제 언어라 불리는 [[Ruby]]는 블록의 끝을 end 키워드로 구분하기 때문에 이런 문제에서는 자유로운 편이다.](들여쓰기에 최적화된 python을 쓰기싫으면 세미콜론과 중괄호, int/char 등을 수시로 많이 사용하게 될 것이다.) [[탭]] 문자는 사용자나 시스템의 설정에 따라 서로 다른 폭의 공백이 생긴다. 문제는 파이썬 인터프리터가 탭 문자 하나를 공백 1문자로 처리한다는 것이다. 탭 문자로 들여쓰기를 처리하면 자신과 다른 탭 설정을 가진 에디터에서 코드를 열어 볼 경우 코드 들여쓰기가 높은 확률로 망가져 버리고, 그걸 교정해보겠다고 들여쓰기에 공백 문자를 혼용하는 순간 해당 소스 코드는 사람이 고칠 수 없는 형태로(시각적으로는 블록이 맞지만 파이썬 인터프리터는 다른 블록으로 인식) 망가져 버린다. PEP-8에 명시된 공식 코딩 가이드에서는 [[스페이스 바]]로 '''공백 4문자'''를 넣기를 권장하고 있다. 물론 이렇게 스페이스 바를 네 번이나 치는 귀찮은 행위를 프로그래머들이 가만 놔둘 리가 없다. PyCharm, VSCode 등 Python 개발자들이 애용하는 최신 에디터는 Tab을 누르면 공백 4개로 자동 변환하여 입력되는 기능이 지원되므로 이들 에디터를 이용하면 공백 4개를 번거롭게 칠 필요가 없어진다.\n\n웃긴건 Python 2는 [[Tab]] 키를 권장한다. 탭 키를 사용하지 말 것을 요구하는 건 Python 3에서 해당하는 이야기. 물론 Python 2에서도 \"Tab 키를 쓸 경우에는 잊어버리지 말 것\"을 이야기하긴 하나, 그렇다면 처음부터 Tab 키를 막았어야 말이 된다. --첨에는 탭이 그렇게 똥인줄 몰랐어....-- [[PyCharm]] 등의 주요 에디터에는 탭 키를 썼는지 스페이스 바를 썼는지 시각적으로 구분하여 보여주는 기능이 있으므로 참고하자.\n\n참고로 위의 예시인 팩토리얼 함수는 (람다식과 ternary operator를 이용해) 다음과 같이 간결히 나타낼 수 있다.  --사실 이 코드는 PEP-8 위반이다. --\n{{{#!syntax python\nfactorial = lambda x: 1 if x == 0 else x * factorial(x - 1)\n}}}C와 Java에서 쓰이는 ternary operator {{{?:}}}에 비해 훨씬 직관적으로 읽혀, '실행할 수 있는 의사코드'라는 별명을 여기서도 느낄 수 있다. 물론 쳐야 할 문자 숫자가 몇 배로 늘어나기 때문에 싫어하는 사람은 엄청나게 극혐한다.\n=== 순수 객체지향 ===\n파이썬에는 원시 타입(Primitive Type)이 존재하지 않으며, 모든 것이 객체로 취급된다. 나아가 클래스, 함수 역시 객체로 취급할 수 있다. 상수 역시 상수가 저장된 객체라고 본다. 다음과 같은 상수 할당문이 있을 때,\n{{{#!syntax python\nx = 10\n}}}\n이는 변수 x 자체에 10이 할당된 것이 아니라 x가 10이 저장된 상수 객체를 가리키는 것을 의미한다. 내부적으로는 C의 포인터 연산과 같은 동작이 행해지는 것이다. 이렇게 x에 대입되는 값을 변경할 경우,\n{{{#!syntax python\nx = 10\nx = 20\n}}}\nx가 가리키는 대상이 10이 저장된 상수 객체에서 20이 저장된 상수 객체로 바뀐 것이다. x 자체의 값이 10에서 20으로 바뀐 게 아니다.\n\n||<#fff>[[파일:2-4-4.png|width=400]]||\n|| [[https://www.onlybook.co.kr/entry/algorithm-interview|<파이썬 알고리즘 인터뷰>]] p.107, 책만, 2020 ||\n\n파이썬 버전 3의 표준 타입 계층 구조에서 주요 자료형은 그림과 같다. 이 중에서도 크게 불변 객체(Immutable Object)와 가변 객체(Mutable Object)로 나눌 수 있다. 불변 객체에는 상수(숫자), 문자열, 바이트, 그리고 튜플[* 튜플을 변경 불가능하게 막는 이유는 보안 때문이다.]이 있다. 이 네 가지를 제외한 나머지 객체는 모두 가변 객체이며, 값을 수정할 수 있다. 불변 객체의 값을 수정할 때는 바뀐 값이 저장된 새로운 객체를 생성하고 참조 대상을 새 객체를 옮기는 식으로 동작한다. 이와 같은 특징 때문에 파이썬은 순수 객체지향 언어라고 할 수 있고, 이와 같은 순수 객체지향 언어의 또다른 예로는 [[Ruby]]가 있다.\n\n함수의 매개변수로 불변 객체를 넘겼냐 가변 객체를 넘겼냐에 따라서 함수 바깥에 있는 인자의 값도 수정할 수 있는지 없는지가 달라진다. 불변객체를 넘겼으면 값의 복사만 일어나고 함수 바깥에는 영향을 주지 못하므로[* global이나 nonlocal 키워드를 사용하지 않았을 경우] '값에 의한 호출(Call by Value)'이 될 것이며, 가변 객체를 넘겼으면 함수 바깥에까지 영향을 줄 수 있으므로 '[[참조에 의한 호출]](Call by Reference)'이 될 것이다. 파이썬 공식 문서에서는 파이썬의 인자 전달 방식을 '할당에 의한 호출(Call by Assignment)', 또는 '객체 참조에 의한 호출(Call by Object Reference)'이라고 명시하고 있다.\n\n=== 반복 가능한 객체 ===\n파이썬의 가장 큰 특징 중 하나. 파이썬은 반복 가능한 객체(iterable)라는 강력한 기능을 제공한다. 이 객체는 집합, 문자열, 리스트, 튜플, 딕셔너리, 그리고 함수[* return 대신 yield를 써서 생성기(generator)를 반환한 경우.]까지도 반복이 가능하며, 이것을 for 구문에서 사용할 수 있게 해준다. 리스트와 튜플 등은 좀 편해지는 정도라 할 수 있지만, 함수의 값을 반복할 수 있다는 것은 큰 장점이다. 그 예로 n의 배수를 구하는 f(n) 함수가 있을 때,\n\n{{{#!syntax python\ndef f(n):\n    x = 1\n    while 1:\n        yield n*x\n        x += 1\n\not = f(2)\nprint ot\nprint next(ot)\nprint next(ot)\n}}}\n와 같은 함수를 만드는 것도 가능하다. 함수를 호출하고 나서도 함수가 완전히 끝나기 전까지는 지역 변수가 남아있으며, 함수가 끝나야 지역변수가 삭제된다. 따라서 함수를 호출할 때마다 x의 값이 증가한다. 이렇게 만들어진 반복 가능한 객체는 \\_\\_next\\_\\_ 함수나 next(객체) 함수, 또는 for ... in 객체 와 같은 문법들을 이용하여 순서대로 값을 호출할 수 있다. 특히 제너레이터의 경우, 미리 만들어놓는게 아니라, 호출 될 때 반환값을 새로 만들어 반환하는 방식이기 때문에 메모리 관리 면에서도 이점이 있다.\n\n== 장점 ==\n=== 높은 생산성 ===\n||<#fff>[[파일:xkcdpython.png]]||\n|| [[xkcd]] [[http://xkcd.com/353/|353화 'Python']] ||\n\n파이썬의 [[아이덴티티]]. '''그 무엇과도 바꿀 수 없는 파이썬만의 특징'''이다. 전 세계의 모든 [[프로그래밍 언어]] 중에서 파이썬 정도의 낮은 난이도를 가지면서, __범용성을 갖추고, 파이썬 수준의 프로그램 개발 속도를 따라잡는 언어가 없다__. 파이썬으로 만든 프로그램을 같은 객체지향 프로그래밍 언어인 [[Java]]나 [[C++]]로 만든다고 하는 순간 숨이 턱 막힐 정도. 이런 언어를 사용하려면 '''설계부터 난감해진다.'''\n\n[[인터프리터]] 언어이면서 우수한 자료형과 다양한 모듈 등을 제공해 개발기간이 단축되는 것이 특징. '[[C언어]]로 2년동안 완성하지 못한 프로젝트를 파이썬으로 한달만에 해냈다'는 극적인 경험담이 있을 정도다. 당장 파이썬의 집합 자료형 같은 경우 C언어로 구현하려고 하면 머리가 아파온다. C언어와의 접착성도 좋기 때문에, 일단 Python으로 빨리 구현하고, 남은 시간에 속도에 병목이 되는 부분을 C++로 전환하는 전략을 내세우고 있다. 버전이 올라가면서 Python 자체도 그리 느리지 않게 되었다. 심지어 [[어셈블리어]] 같은 저수준 언어(Low level)도 Python에서 호출 할수있다. Python은 어지간한 다른 프로그래밍 언어들을 지원하는 호환성, 응용할 곳이 무궁무진하다.-- 실행 속도만 빼고--\n\n참고로 저~~ geek 감성의 재미없는~~ [[xkcd|만화]]는 파이썬 내에 [[이스터 에그]]로 삽입되기도 했다. import antigravity로 antigravity 모듈을 불러오면 나온다.[[http://www.youtube.com/watch?v=_V0V6Rk6Fp4|영상]]\n=== 문법 통일에 따른 빠른 피드백 ===\n디자인 철학 자체가 '''가장 완벽한 하나의 아름다운 해답'''을 찾는 파이썬 특유의 철학을 찾다 보니, [[문법]] 자체가 딱 떨어지게 표현된다. 이 때문에 다른 사람이 제안하고 만든 프로그램을 수많은 사람들이 보고 쉽게 접근할 수 있다. [[Perl]] 같은 경우는 '''Write Once, Read Never'''라고 불릴 정도로 [[피드백]]과는 담을 쌓았는데, 파이썬은 문법이 통일되어 있다 보니 '''Write Once, Read Infinity'''가 되어버렸다. 그래서 프로그램 하나 만들면 다른 프로그래머들에 의해 엄청난 양의 피드백이 들어오게 되었고, 이는 곧 생산성 향상으로도 이어졌다. 괜히 파이썬이 [[https://www.tiobe.com/tiobe-index/python/|시간이 갈수록 점유율이 상승하는 언어]]가 아닌 것이다.\n\n=== 과학/공학 친화 ===\nPython은 과학과 공학 분야에서 필요한 여러 기능을 기본적으로 제공한다. 우선 언어 자체적으로 64비트를 넘어가는 매우 큰 정수를 지원한다.[* 다른 언어의 경우 64비트를 넘어가는 매우 큰 수를 사용하려면 [[Java]]의 BigInteger, [[JavaScript]]의 BigInt와 같이 별개의 클래스를 사용해야 한다.][* 큰 수 계산하기 위한 내장 함수들을 Python 2부터 저장해두었기 때문에 가능하다. 유감스럽게도 큰 수 활용 부분은 Python 2와 3가 호환이 안 되는 지점 중 하나다. 내장함수 몇몇이 2와 3에서 기능이 다르다.] 또한 [[허수]]를 기본적으로 지원하며, 표준 라이브러리의 [[https://docs.python.org/3/library/decimal.html|decimal]], [[https://docs.python.org/3/library/fractions.html|fractions]] 모듈을 사용해 소숫점과 유리수를 정밀하게 다룰 수 있다. 따라서 이러한 기능을 다루는 암호학과 통계 분야에서 쓰기에 알맞다.\n\nPython 생태계 또한 공학 및 과학 분야를 빵빵하게 지원한다. 복잡한 수치와 큰 데이터를 다루는 연산에 알맞은 NumPy, SciPy, pandas, 데이터를 그래프로 시각화하는 Matplotlib, 코드와 데이터를 함께 다룰 수 있는 Jupyter Notebook 등의 강력한 패키지와 도구를 사용할 수 있다.\n\nPython 개발자들도 이러한 사실을 잘 알고 있기 때문에 언어 차원에서 관련 패키지를 위한 기능을 제공한다. 가령 [[https://docs.python.org/3/library/constants.html#Ellipsis|Ellipsis]] ({{{...}}}) 상수는 사실상 NumPy 전용의 슬라이스 객체로 제공한다.[* Python 3.5에서 추가된 [[https://docs.python.org/3/library/typing.html|typing]] 모듈에서도 길이가 가변적인 tuple을 나타내기 위해 사용한다.] 또한 3.5부터는 [[행렬곱]]을 위한 {{{@}}} 연산자가 [[https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-465|추가되었다]].\n\n=== 만능 언어 ===\nPyPI[[https://pypi.python.org/pypi|#]]라는 [[패키지 저장소]]가 2012년 구축되었다. 2018년 10월 기준 155,800 여개의 패키지를 제공한다. 여기에 등록된 패키지들은 pip[[https://en.wikipedia.org/wiki/Pip_(package_manager)|#]]를 통해 간단하게 내려받을 수 있다. 다만, PyPI가 최초, 최대의 패키지 저장소는 아니다.\n\nPython으로 직접 만들었거나 또는 다른 프로그램의 Wrapper가 꼭 존재한다. 사실상 못하는 것이 없다. 웹 사이트 서버를 구현하려고 하면 Python Web Framework를 쳐보자([[Django]], [[Flask]], [[Bottle]] 등). [[기계학습]] 알고리즘을 쓰고 싶다면 python machine learning이라 검색하자([[scikit-learn]]). 얼굴인식을 코드 몇 줄로 할 수도 있다([[OpenCV]]). 기본적으로 설치되는 모듈인 tkinter 모듈을 이용하면 간단한 GUI 프로그래밍을 할 수 있다. 게임도 만들 수 있다([[Pygame]]). 비주얼 노벨도 만들 수 있다([[Ren'Py]]).\n\nPython 가지고 [[스프레드시트]]나 [[데이터베이스]]까지 만드는 괴수들도 있다. Python으로 [[SQL]]을 구현하는 건 불가능하다는 소리가 있었지만 우리의 [[Nerd]]들은 해내고 말았다. [[2013년]] Python으로 관리하는 DB 개념이 잡힌 이후 수많은 [[피드백]] 끝에 [[2015년]] 도전 성공. 심지어 [[2017년]] [[프랑스]]의 중견기업에서 Python DB 프로젝트를 보더니 정말로 회사의 DB를 파이썬으로 관리하는 사업을 벌려서 DB화되지 못하고 저장되던 회사 내부의 파일형 자료들과 기존의 DB에 저장된 자료를 접합시키는 사업까지 했다 한다.\n\n물론 그렇다고 Python만 쓰는 것이 답은 아니다. 실행 속도(정확히는 CPython의 실행 속도)가 상대적으로 느린 편이라, 빠른 속도가 필요한 프로그램 작성에는 한계가 있다. 일반적으로 기계어로 컴파일하여 사용하는 [[C(프로그래밍 언어)|C]], [[C++]]보다는 당연히 느리고, [[Lua]], [[JavaScript]], [[LISP]] 계열 언어 등 동적 언어들을 전체를 주욱 놓고 비교해 봐도 속도가 빠른 편은 아니다. Python처럼 가상 머신 위에서 실행되는 [[Java]], [[JavaScript]] 등의 언어들의 경우, 속도 문제를 극복하기 위해서 [[JIT]] 컴파일러를 도입했다. Python의 사실상의 표준 구현체인 CPython은 JIT 컴파일을 도입하지 않았고, JIT 컴파일을 도입한 별도의 구현체인 PyPy가 등장했다. 통계 분야 등 특정 분야에서는 [[R(프로그래밍 언어)|R]]과 같이 그 분야에 특화된 언어를 사용하는 것이 더 편리할 수도 있다.\n\n그리고 동적 타입 언어(dynamically typed language)라는 점이 큰 프로젝트에서는 단점으로 작용하여 자료구조 설계나 디버깅이 어렵다는 지적도 있다. 다만 \"정적 타입 vs. 동적 타입\" 논쟁은 서로의 장단점이 있으며 일종의 종교 논쟁으로 취급 받는다. 일례로 OCaml 같은 강력한 타입 인터페이스(Hindley-Milner, System F 등)를 가진 경우, 모든 타입 에러(!)를 컴파일 타임에 잡아낼 수 있는 반면에, 모든 버그가 타입 에러는 아니기 때문에 여전히 테스트 및 디버깅 과정은 필요하며, 타입 시스템으로 인한 부담 때문에 빠른 구현에는 부담이 될 수 있다. 반면에 동적 언어는 빠른 구현의 이점이 있지만 타입 에러가 많이 나는 특징이 있다. 한 마디로, 컴파일 언어의 경우에는 컴파일 시간에 잡아낼 수 있는 오류를 범하게 된다는 소리. Python으로 parser를 많이 작성해봤다면, 십중팔구 읽은 숫자를 string으로 저장했다가 나중에 연산을 했더니 연산이 불가능하다면서 에러가 나거나 이상한 결과가 나온 경험이 있을 것이다.\n\n그러나 이는 커버리지가 높은 테스트 세트로 어느 정도 커버할 수 있으며 최근의 추세와 부합하는 방식이기도 하다. 또한 Python 3.5부터는 Type Hints를 이용해서 변수가 가질 수 있는 타입을 지정할 수 있게 되었다. 성능 향상에 도움은 안되지만 가능한 오류를 쉽게 찾아낼 수 있으며 [[PyCharm]]과 같은 IDE 프로그램을 이용하면 도움을 받을 수 있다.\n\n빠른 아이디어 구현이 생명인 연구소에서 각광을 받고 있고, 한국 밖에서는 당당한 주류 언어로 대우받고 있다. [[인스타그램]], [[유튜브]], [[reddit]] 등이 Python을 주로 쓰고 있다고 알려져 있으며, 외국의 구인 사이트에도 Python을 할 줄 아는 사람에 대한 수요가 많다. 컴퓨터 관련이 아닌 이공계 전반에서 많이 쓰이는 [[MATLAB]]은 오픈소스가 아니라는 점이 최근 추세와 맞지 않아 입지가 좁아지고 있다.[* MATLAB의 GUI 기반 모델링 툴박스인 Simulink는 기업용으로 구매하면 기본 toolbox가 1 copy에 천만 원 단위, 각종 전기, 전자, 기계, 유압, 항공 등에 관련한 라이브러리는 추가로 유료로 판매한다. 거기에 C로 포팅 해주는 모듈도 역시 개별적으로 추가 구매해야 한다. 만약 오픈소스 소프트웨어로 Simulink를 대체하고자 한다면 현재로서는 FMI 기능 및 C 코드로의 오토코딩 모듈이 있어야 할 것이다. 게다가 패키지 설치를 참 더럽게 이상하게 만들어 놨다. MATLAB과 같은 목적의 Python 패키지인 [[NumPy]]는 모종의 계약을 통해 문법과 함수 등의 많은 부분에서 MATLAB 함수와 호환되게 수정해 버렸고, 안 그래도 꽤 쓰였던 NumPy는 더욱 사용자가 늘어나고 있다. Python의 경우는 지원 라이브러리의 대부분이 오픈소스이기 때문에 저장소에서 그냥 커맨드 라인(pip install 패키지) 한 줄로 필요한 거의 모든 패키지를 설치해서 쓸 수 있다.] CG 업계에서도 사실상 표준으로 사용되는 스크립트 언어이다. [[Autodesk Maya|MEL]], [[3ds Max|MAXScript]] 등 툴별로 자체 스크립트 언어들이 난립하고 있었는데, 현재는 Python 스크립팅을 주력으로 밀고 있다.\n\n요즘은 가히 춘추전국시대라고 할 수 있을 만큼 새로운 언어와 프레임워크가 계속 등장하고 있으며, 아예 [[폴리글롯]](Polyglot[* 원래 언어 쪽에서 Multilingual과 같은 뜻으로 쓰이나, 컴퓨터, IT 업계에서는 여러 프로그래밍 언어를 능숙하게 구사하여 적재적소에 잘 조합하여 쓸 수 있는 능력을 뜻한다.]) 프로그래밍이라는 용어가 등장하는 시대다. 당장 [[구글]]만 해도 C++, Java, Python을 골고루 섞어서 쓴다고 알려져 있으며, 게임도 메인은 C++로 작성되었지만 스크립팅은 Python이나 [[Lua]]로 된 경우([[시드 마이어의 문명]], [[WOW]] 등)를 매우 쉽게 찾아볼 수 있다. 따라서 필요하다면 프로그래밍 언어를 가리지 않고 매우 능숙할 수 있게 사용할 수 있도록 공부해야 하며, 알고리즘, 디자인 패턴, 테스트 기법, 동시성 프로그래밍(멀티스레드, 멀티프로세스) 등의 필요한 지식을 훤하게 꿰고 있어야 제대로 된 프로그래머/개발자가 될 수 있다.\n\nPython으로 할 수 있는 것들을 모아 놓은 곳도 있다! [[https://github.com/vinta/awesome-python|Awesome Python]]\n=== 교육 ===\n파이썬은 위의 특징 때문에 교육용 프로그래밍 언어로 각광받고 있다. 한국, 미국의 여러 대학교 프로그래밍 교육들은 개론 수업 언어를 C, C++나 Java에서 Python으로 옮겨가는 추세다. \n\n주의할 점은 Python이 배우기 쉽다는 건 프로그래머 입장에서 나온 말이라는 것이다. 그마저도 다른 언어에 비해 비교적으로 쉽다는 뜻이지, 깊게 파고 들어가거나 특유의 '파이썬스러움(pythonic)'한 코딩을 하려면 생각보다 신경쓸 것도 많고 동적 언어에 익숙해져 있어야 한다. 더욱이 컴파일러 없이 프로그래밍 하는 것은 깡초보에게 권장할 만한 것이 아닌게, 정적 언어에 대한 개념도 없이 동적 언어를 잡았다가는 오히려 더 헷갈릴 수 있다. 왜 마이크로소프트가 [[TypeScript]]를 만들었는지 잠시 생각해 보기 바란다. 더욱이 파이썬은 편집증이 의심될 정도로 객체 위주로 돌아가긴 하지만, 언어의 패러다임을 보면 절차지향, 객체지향, 함수형 모두 사용할 수 있는 언어다. 극단적으로 OOP를 지향하는 Java나 C#보다[* 모든 함수가 일단 클래스 안에 있어야 하며, 전역 함수는 static 함수를 사용하는 형태로 짜야 한다.] 더 신경써야 할 것이 많다는 이야기. 하여튼 프로그래밍 자체를 마냥 쉬운 것으로 생각하다면 큰 코 다친다. 프로그래밍을 쉽게 할 수 있는 것과 좋게 하는 것에는 큰 차이가 있으며, '좋은' 프로그래밍을 하는 것은 프로그래머의 역량에 크게 좌우된다.\n\n== 문제점 ==\n파이썬은 시스템을 건드리거나 반복연산이 많은 것은 하기 어렵지만 python num 처럼 따로 모듈을 지원하기 때문에 크게 걱정할 필요는 없다(그래도 python num을 사용해도 느린건 느리다;;).\n이 단점은 반복 연산이 있는 C를 사용하여 작성하면 사라진다.\n\n=== 멀티스레딩 불가 문제 ===\n파이썬은 [[스레드#s-3|멀티스레딩]]을 지원하기 위하여 GIL(Global Interpreter Lock), 즉 전역 인터프리터 락을 도입하여 사용하게 되었다. 따라서, python 스레드 10개를 만들어도 실제 Pthread/윈도우 스레드가 10개가 만들어지긴 하는데, GIL때문에 개중 동시에 하나밖에 안돌아가는 기이한 구조를 갖고 있다. 물론, 내부적으로 IO작업이 있을 시 바로 다른 스레드로 문맥 교환을 해주고, 바이트 코트를 100번 실행한 다음에는 인터프리터 차원에서 다른 스레드로 교체 해주므로 동시 작업 비슷한 효과가 난다. 이것은 구현이 매우 쉬워지고 빠른 개발을 할 수 있다는 장점이 있으나, 다중 코어 CPU가 보편화된 2006년 이후에는 다중 코어를 제대로 활용하지 못하는 구조적인 문제 때문에 성능에서 밀린다는 평가를 받게 되었다. 만일 특정 프로그램에 순진하게 CPU 코어를 2개 이상 동원하려고 할 경우, 뮤텍스(MutEx), 즉 한 스레드에 여러 개의 CPU가 연산을 행하여 내부 정보를 오염 시키는 것을 방지하는 역할을 맡는 GIL이 병목 현상을 일으켜 코어 하나를 쓸 때보다 오히려 성능이 크게 저하된다는 것. 구글 내부에서 이미 가루가 되도록 까인 부분이다.\n\n더불어, 예전의 Python에는 CPU-bound한 스레드가 I/O-bound한 스레드와 함께 돌아갈 때, I/O-bound한 스레드가 실행되어야 할 상황에서도 context switch가 제대로 이루어지지 않는 문제가 있었다. 이 때문에 CPU-bound 스레드가 GIL을 지나치게 오래 점유하게 되면서 I/O 반응 속도가 느려지고, 다른 스레드는 GIL을 획득하려고 계속 시도하느라 CPU 시간을 낭비하게 되었다. 이에 대해 파이썬 전문가인 [[https://www.dabeaz.com/|David Beazley]]가 2009년에 [[https://archive.org/details/pyvideo_588___mindblowing-python-gil|Mindblowing Python GIL]]이라는 강연에서 지적하였다.[* [[http://www.dabeaz.com/GIL/|Beazley의 홈페이지]]에서 더 많은 시각 자료와 영상을 제공하고 있다.] 이후 Antoine Pitrou라는 개발자가 GIL을 뜯어고쳐 해당 문제를 해결하였고, [[https://docs.python.org/3.2/whatsnew/3.2.html#multi-threading|Python 3.2부터는 새로운 GIL이 적용되어서]] 성능이 어느 정도 개선되었다.\n\n이런 문제점 때문에 파이썬에서 병렬 처리가 필요할 때는 다중 [[스레드]]가 아닌 다중 프로세스로 GIL을 우회하는 방식을 사용한다. 2008년 이후에 multiprocessing이라는 모듈을 제공하는데 이 모듈은 자식 프로세스를 만드는 방향으로 다중 코어 사용 시 성능의 향상을 꾀하고 있다.\n\n단, CPU 부하가 큰 작업을 돌리는 것이 아니면 GIL을 체감하기는 생각보다 쉽지 않다. 다중 스레딩으로 CPU의 여러 코어를 최대한 이용하고 싶은 경우에는 GIL가 굉장히 아쉬운 이슈지만, CPU를 별로 쓰지 않거나 I/O가 주가 되는 작업은 유의미한 성능 차이가 없다. 게다가 어설프게 코어 몇개 깔짝깔짝 이용해서 계산하는 것보다는 그냥 C언어로 모듈을 짜서 붙이는 게 더 빠르다. 즉, python에서 CPU를 많이 먹는 부분은 C 모듈을 짜서 붙이거나, 이미 C 모듈로 짜여있는 라이브러리를 사용하거나(Numpy, Scipy 등), 필요하다면 multiprocessing 모듈을 이용하여 멀티코어를 활용하는 편. 그 이상의 CPU-heavy한 작업은 처음부터 [[C]], [[C++]]로 짜는 게 맞다.\n\n자세히 알고 싶다면 다음 링크들을 참조.(너무 오래된 링크들이라 차라리 인터넷 검색해서 최근 글들을 보기 바란다.)\n\n * [[http://highthroughput.org/wp/cb-1136/|파이썬 GIL 깊숙히! (上) (2006년도)]]\n * [[http://highthroughput.org/wp/cb-1146/|파이썬 GIL 깊숙히! (上) 에 대한 몇 가지 변명 (2007년도)]]\n * [[http://highthroughput.org/wp/python-multiprocessing/|“파이썬은 멀티코어 줘도 쓰잘데기가 없나요?”에 대한 파이썬 2.6의 대답 (2008년도)]]\n * [[http://www.youtube.com/watch?v=Obt-vMVdM8s|Understanding the Python GIL (유튜브) (2010년도)]]\n * [[http://deview.kr/2014/session?seq=47|Python에서의 동시성/병렬성 (2014년도)]]\n\n하지만 대규모 연산의 멀티코어의 성능 향상을 보기 위한 것 말고도, I/O가 주가 되는 작업(즉, 여러 개의 I/O 이벤트를 기다리는 것)을 위해서 멀티스레드를 사용하는 경우가 많고,[* 사실 GIL 방식으로 만들 당시 싱글코어가 일반적이었다는 걸 생각해보면 싱글코어에서의 멀티쓰레딩 목적 자체가 멀티코어 성능 향상보다는 이런 다중 이벤트 루프 구현을 하기 위한 것이라고 봐야 하며, 그런 관점에서는 GIL이 합리적인 선택이었다고 할 수 있다.] 이런 경우에도 복잡한 동기화를 해야 하는 멀티쓰레딩을 사용하는 건 낭비이다. 왜냐하면 디버깅도 힘들 뿐만 아니라, 실제로는 I/O를 위해 기다리는 시간이 실제 I/O가 발생했을 때 필요한 처리 작업을 수행하는 시간보다 월등히 긴 경우가 많아 여러 개의 스레드를 관리하기 위한 자원만 낭비하는 꼴이기 때문이다.\n\n따라서 [[Go(프로그래밍 언어)|Go]]나 [[Erlang]] 같은 최근의 프로그래밍 언어들은 [[코루틴]]이란 개념을 도입해[* 단, 코루틴이라는 개념 자체가 이런 최근의 프로그래밍 언어에서 처음으로 등장한 것은 아니다. 코루틴의 개념은 1950년대에 이미 나왔다.] 이러한 \"event multiplexing\"을 싱글스레드로도 구현할 수 있게 하고 있다. 특히 멀티쓰레딩할 때 필요한 각종 동기화 문제 없이 마치 싱글 스레드 코드를 짜는 것과 거의 동일한 방식으로 코드를 작성할 수 있으면서도 그러한 코드들이 \"동시에\" 동작하는 것처럼 실행해주므로 프로그래머 입장에서 매우 편하다. 실제로는 각 이벤트에 필요한 처리를 하고 다음 이벤트가 발생하기 전까지 비는 시간에 다른 이벤트를 처리하는 코드를 실행시켜주는 방식으로, 시분할과 비슷하지만 문맥 전환이 프로그래머가 작성한 코드에서 명시적으로 다음 이벤트를 기다려야 할 필요가 있을 때 협력적으로 발생한다는 차이점이 있다.\n\n[[C(프로그래밍 언어)|C]]같은 언어에서 이러한 코루틴 지원이 잘 안 되는 이유는, 언어적 차원에서 함수 중간에 실행을 멈추고 다른 함수를 실행할 수 있게 해줘야 하는데 스레드 별로 stack이 1개밖에 없는 구조에서는 구현이 어렵고 하나의 함수로 짜야 할 내용을 여러 개의 [[callback 함수]]로 쪼개면 코드가 지저분해진다는 단점이 크기 때문이다. 이런 callback형태를 사용하는 게 [[Node.js]] 개발 환경이다. 현재로써는 이런 콜백 방식이 유연하면서 퍼포먼스가 좋은 방식이지만 언어적으로 약간 더럽다. 위에서 기술한 Stackless Python에서 코루틴을 먼저 지원할 수 있었던 것도 이런 배경이 있다.\n\n다행히 Python은 (stackless가 아니더라도) yield 키워드를 통해 함수 실행 흐름을 제어할 수 있다. Python 3.4 버전부터는 표준 라이브러리의 각종 파일 입출력, subprocess, socket 통신 등의 기능들을 모두 코루틴화 해주는 asyncio 패키지가 기본 탑재되었다. Python 3.5 부터는 [[C##]]를 본딴 async 함수 선언자와 await 키워드가 포함되어 asyncio 라이브러리에 의존할 수밖에 없던 코루틴 기능을 다른 서드파티 라이브러리도 보다 쉽게 지원할 수 있도록 바뀌고, 코루틴 내부에서의 예외처리 과정이 개선되었다.\n\n==== 멀티코어로 프로그램 돌리기 ====\n[[유닉스]], [[리눅스]], [[macOS]]의 파이썬에서 [[멀티코어]]를 쓰려면 아래와 비슷한 방식으로 [[소스 코드]]를 적으면 된다.\n\n{{{#!syntax python\nimport multiprocessing as mp\n\ndef work(job_list):\n    return job_list + 1\n\np = mp.Pool(4)\np.map_async(work, job_list).get()\n}}}\n\n[[윈도우즈]]는 [[포크]](fork) [[함수]]가 없어 아래 [[코드]]를 추가해야 한다.\n\n{{{#!syntax python\nif __name__ == '__main__':\n    mp.freeze_support()\n}}}\n\n[[https://blog.naver.com/ossiriand/220548193193|[python] 파이썬으로 시도해보는 멀티 코어 프로세싱, 자고 있는 코어들을 깨우기 2015. 11. 24.]]\n\n=== 난잡한 패키지 관리 및 하위 호환 에러 ===\n최신 언어에 비해 패키지를 설치하거나 만들어 배포하는 방식이 복잡하다. 이는 역사가 오래된 언어이다 보니 패키지를 다루는 방식이 여러 차례 바뀌었기 때문이다.\n\n==== 패키지 설치 및 관리 ====\n오늘날 파이썬 라이브러리를 설치할 때는 주로 pip을 이용한다.\n{{{pip install <패키지명>\n}}} 이 방식은 모든 패키지를 기본적으로 설치된 파이썬에 추가하기 때문에 몇 가지 문제가 생긴다.\n\n우선 여러 프로젝트를 동시에 작업할 때 호환성 문제가 생길 수 있다. 가령 프로젝트 A는 라이브러리 X의 1.1 버전을 사용하는데, 다른 프로젝트 B는 호환성 문제 때문에 X의 1.0 버전을 사용해야 할 경우가 있다. 이 경우 라이브러리 X의 1.1 버전과 1.0 버전을 동시에 설치할 수 없기 때문에, ''가상 환경''이라는 것을 만들어 프로젝트 A와 B에서 사용하는 패키지를 분리해야 한다. 가상 환경은 [[https://virtualenv.pypa.io/|virtualenv]]라는 도구를 이용해 만들 수 있으며, Python 3.3부터는 표준 라이브러리에 포함된 [[https://docs.python.org/3/library/venv.html|venv]] 모듈을 직접 호출하여 만들 수 있다.\n{{{# virtualenv를 사용할 경우\nvirtualenv my-venv\n# venv를 사용할 경우\npython -m venv my-venv\n}}} 위의 명령은 현재 디렉토리에 {{{my-venv}}}라는 가상 환경을 생성한다.[* JavaScript의 [[npm]]이 {{{#npm init}}}으로 프로젝트를 생성하는 것과 비슷하다.] 일반적으로는 가상 환경 이름도 {{{venv}}}로 한다.\n\n또한 pip은 패키지 간의 호환성을 꼼꼼하게 따지지 않는다. 가령 위의 프로젝트 A와 B를 남들이 사용할 수 있게 라이브러리로 만들었다고 하자. 다른 컴퓨터에서 pip을 사용해 A를 설치하면 A가 필요한 X의 1.1 버전이 설치된다. 이후 B를 설치하면 X의 1.1 버전을 삭제하고 1.0 버전을 설치하기 때문에 A를 쓸 수 없게 된다.[* 반대로 B부터 설치한 다음 A를 설치하면 B가 쓸 수 없게 된다.] npm과 같은 현대적인 패키지 관리자들은 패키지 호환성을 꼼꼼하게 검사하기 때문에 이런 상황에서는 B를 설치하려 하면 거부하지만, pip은 그런 거 없다.\n\n리눅스와 같이 자체적으로 파이썬을 탑재한 운영체제에서는 호환성 문제를 특히 신경써야 한다. 시스템에 내장된 핵심 도구들이 기본적으로 설치된 파이썬 라이브러리를 사용하기 때문이다. 만약 패키지를 설치하다가 호환성 문제가 생기면 최악의 경우 OS를 재설치해야 할 수 있다. 따라서 이런 OS에서는 시스템 내장 파이썬에 패키지를 설치하면 안 되며, 대신 {{{#pip install --user}}}로 사용자별 기본 환경에 설치하거나 별도의 가상 환경을 만들어야 한다.\n\n혹여나 프로그램 간 접합 등을 이유로 파이썬의 라이브러리를 사용하다 해당 기능을 외부 모듈(.msi, .exe, .pkg등의 설치파일)을 이용해 서버에 내장하여 돌리려는 때에는 정말 지옥을 맛볼 수 있다. 파이썬의 라이브러리가 불러오는 코어와 서버에 설치되는 모듈이 불러오는 코어가 다르기 때문. (--다른 것이 코어 경로뿐이라면 그나마 낫지만 내부 로직마저 다르다면...?--이런 경우는 상상하면 수명만 줄어들 뿐이다.) 이를 고치려면 에러의 콜스택을 따라가며 어디서 문제가 생겼을지 머리를 쥐어짜고 모듈 내의 코드를 뜯어 고치는 수밖에 없다. \n사실 이 문제는 다른 언어에서도 있을 수 있는 일이다. 다만 파이썬의 경우 패키지 버전의 통일성 부족과 만나버리는데, 버전에 따라 천차만별로 다를 이 대처법들이 인터넷 온갖 구석을 다 뒤져도 나오지 않아 아스트랄한 난이도를 선사한다. (나오긴 하지만, 해결되지 않는 경우가 많다. 물론 직접 질문을 올려도 대부분 답은 안나온다.) 차라리 처음 발견되면 사용하는 라이브러리나 내부 구조를 바꿔서 피해갈 수 있지만, 이미 진행될대로 진행된 프로젝트인 경우 그저 행운이 함께하길 빌 뿐이다.\n==== 패키지 개발 및 배포 ====\n파이썬으로 만든 프로그램이나 라이브러리를 다른 사람들이 사용할 수 있게 만들려면 복잡한 과정을 거쳐야 한다.\n\n파이썬의 라이브러리 개발 방식은 세월이 흐름에 따라 여러 차례 바뀌었다. 패키지 관리자라는 개념이 없어서 각자 프로그램의 소스 코드를 다운로드해 쓰던 시절에는 {{{setup.py}}}라는 설치 스크립트를 각자 만들어서 파이썬 프로그램과 함께 배포하는 것이 관행이었다.[* 복잡한 설치 스크립트가 필요한 이유는 여러 OS 간의 호환성 문제를 해결하기 위함도 있지만, C와 C++ 코드를 함께 사용한 라이브러리를 배포하기 위함이다. 이러한 언어는 해당 OS에 맞게 컴파일해야 하는데, 수많은 OS에 맞춰 컴파일하는 것은 문제가 있다.] 이를 언어 차원에서 지원하기 위해 Python 1.6부터는 [[https://docs.python.org/3/distutils/|distutils]]라는 빌드 도구를 기본 탑재하였다. 그런데 distutils는 자신의 프로그램이 필요로 하는 다른 패키지를 설치하지 못한다는 치명적인 문제가 있어서[* 가령 내가 만든 패키지 A가 B에 의존하고, B는 C에 의존할 경우, 예전에는 사용자가 A, B, C를 일일이 설치해야 했다.], 이를 해결하기 위해 [[https://setuptools.readthedocs.io/|setuptools]]라는 도구가 등장하였다.\n\n세월이 흘러 pip이라는 패키지 관리자와 PyPI라는 패키지 저장소가 등장하면서, {{{setup.py}}}를 만드는 기존의 방식의 단점이 부각되었다.\n\n * {{{setup.py}}}를 실행하는 데 필요한 도구[* setuptools나 설치에 필요한 다른 기능. 또한 C/C++ 코드를 사용하는 경우에는 해당 시스템에 C/C++ 컴파일러도 설치되어 있어야 한다.]가 있는지 확인하고, 없으면 자동으로 설치하거나 사용자에게 알려주는 기능이 없다.\n * {{{setup.py}}}는 파이썬 코드로 작성하기 때문에 패키지 이름이나 버전과 같은 메타데이터를 추출하는 것이 까다롭다.\n * {{{setup.py}}}에는 아무 파이썬 코드나 넣을 수 있으므로 악의적인 코드를 심을 수 있다.\n * {{{setup.py}}}는 setuptools를 직접 {{{import}}}하기 때문에 사용자가 다른 빌드 도구를 선택할 수 없다.\n\n이 때문에 {{{setup.py}}}를 작성하는 대신 {{{pyproject.toml}}}[* [[npm]]이 사용하는 {{{package.json}}}과 유사하지만, [[https://en.wikipedia.org/wiki/TOML|TOML]]이라는 파일 형식을 사용한다.]이라는 설정파일을 사용하는 표준안인 [[https://www.python.org/dev/peps/pep-0518/|PEP-518]]이 등장하였다. pip 10.0부터는 {{{pyproject.toml}}}을 지원한다. 다만 운영체제 중에는 최신 버전의 pip을 탑재하지 않은 경우도 많기 때문에 pip을 업데이트해야 한다. [[https://flit.readthedocs.io/|flit]]이나 [[https://python-poetry.org/|Poetry]] 등의 개발 도구를 사용하면 {{{setup.py}}}를 작성하지 않고 패키지를 만들어 배포할 수 있다. 물론 예전 방식대로 distutils/setuptools를 사용하면서 {{{setup.py}}}과 {{{pyproject.toml}}}를 함께 사용하는 것도 가능하다.\n\nPython 으로 개발한 SW를 공개 배포하는 경우 소스 코드가 그대로 노출된다. 예를 들어 상용 프로그램이나, 보안을 유지해야 하는 경우 파이썬 코드를 숨겨야 한다. \n * Py파일을 Bytecode로 컴파일하는 방법[[https://kibua20.tistory.com/72|#]]\n * PyInstaller를 사용해서 EXE 또는 ELF 형식의 실행 파일을 만드는 방법 [[https://kibua20.tistory.com/93|사용법과 주의사항]]\n가장 쉬운 방법은 byte code인 pyc파일로 변환하는 방법이다. 하지만, 이 방법은 조금만 노력하면 디컴파일이 쉽게 되기 때문에 코드를 숨길 수 없고 다만 코드 보기를 조금 어렵게 만드는 것으로 이해해야 한다. Pyc 파일보다 나은 방법은 PyInstaller를 사용하는 방법이다. PyInstaller는 Py파일을 종속성을 분석해서 필요한 shared lib를 하나에 폴더에 패키징하고, EXE나 ELF의 실행 파일을 생성하여 소스 코드를 숨길 수 있다. PyInstaller로 패키징하는 과정에서 --key 옵션을 사용하면 AES256 으로 Bytecode를 암호화한다.\n\n\n== 다양한 python 구현체 종류 ==\n보통 말하는 Python은 [[C(프로그래밍 언어)|C]]로 구현되었으며, 다른 구현체와 구분하여 언급할 때는 [[CPython]]이라고 표기한다. [[https://hg.python.org/cpython/file/tip|#1]] 또는 [[https://github.com/python/cpython|#2]]에서 [[소스 코드]]를 열람해볼 수 있다.\n\n[[Stackless Python]]은 CPython에서 C 스택을 없앤 것이다.\n\n[[Cython]]은 파이썬 소스 코드를 [[C 언어]] 코드로 변환하여 [[컴파일]]한다.\n\n[[Pyston]]은 [[C++]]로 구현되었다.\n\n파이썬 자체로 구현된 [[PyPy]]도 있다. Pyston과 PyPy는 [[JIT]]가 구현되어 있다.\n\n[[Java]]로 구현되어 [[Java Virtual Machine]] 위에서 돌아가는 [[Jython]]과 [[C\\#]]으로 구현된 [[.NET#Framework|.NET Framework]] 위에서 동작하는 [[IronPython]]이 있다.\n\nJython과 IronPython은 [[가상머신]]에서 동작하는 구현체이다. 시작부터 [[JVM]] 또는 [[.NET]] CLR 위에서 동작하는 Python 구현체를 도입하는 경우는 매우 드물다. 기존에 Java나 .NET Framework에서 개발되어 운영되던 프로그램이나 시스템이 존재하고, 이 환경 하에서 Python의 간결하고 편리한 기능과 높은 생산성을 도입하고자 할 때 사용된다. \n\nJython과 IronPython은 둘 다 CPython에 비하면 실행 속도가 매우 느리며, Jython은 경우에 따라서 심각할 정도로 많이 느리다. 따라서 주요 기능을 수행하는 데에는 문제가 있지만, 보조 기능에서 사용하면 번거로운 작업들을 매우 손쉽게 Python 스크립트로 Java, .NET Framework의 자원을 그대로 끌어다 써서 할 수 있기 때문에 개발 공수와 편리함에서 큰 장점이 있다.\n\n[[JavaScript]]로 구현한 [[Brython]]과 [[Skulpt]]도 있다. [[https://www.pythonpad.co/pads/new/|Pythonpad]]에서 Brython 기반으로 코드를 실행해볼 수 있다.\n\n한편 [[중국]]에서는 [[Chinese Python]]이라는, 중국어 문법으로 한자를 쳐서 돌아가는 언어를 독자 개발했다.\n\n=== [anchor(stackless)]Stackless Python ===\n[[http://stackless.com/|홈페이지]]\n\n파이썬의 표준 구현인 CPython은 이름 그대로 [[C(프로그래밍 언어)|C]]로 만들어져 있는데, 파이썬 프로그램의 함수 호출 [[스택]](Call stack)을 구현할 때 그만 C의 호출 스택[* C 시간에 스택 영역 힙 영역 할 때 나오는 그 스택이다.]에 그대로 얹어가도록 구현되고 말았다. 때문에 파이썬에서 얼마나 메모리를 많이 쓸 수 있느냐에 관계없이 C 호출 스택을 꽉 채우는 순간 그대로 [[스택 오버플로우]] 에러가 뜨게 되어버렸고[* C 레벨에서 만들어주는 스택이라 \"C로 짜여진 프로그램\"인 CPython은 손을 댈 수가 없다. --원칙적으로는 말이지-- ], 파이썬 프로그램의 호출 스택, 즉 프로그램의 실행 흐름을 CPython 스스로 제어할 수가 없게 되어 [[코루틴]] 등의 실행 흐름을 제어하는 언어 기능을 쓸 수 없게 되고 말았다.\n\nChristian Tismer라는 개발자는 이 문제를 타파하려면 \"CPython 소스코드를 수정해서[* CPython은 [[http://docs.python.org/license.html|GPL 호환의 독자 라이선스를 가진 오픈소스 프로젝트]]다.] C 스택을 쓰는 부분을 전부 들어내고 새로 호출 스택을 짤 수밖에 없다\"고 생각했고, 그것을 실제로 실행에 옮긴 것이 Stackless Python이다. 이름의 Stackless는 그래서 사실 C 호출 스택이 없다는 의미. Stackless Python은 스택 오버플로우 에러가 덜 난다는 사소한 장점[* 메모리의 용량이 유한한 이상 스택 오버플로우 에러가 안 날 수는 없다.] 외에도, 스스로 제어할 수 있는 자체적인 호출 스택을 갖고 있기 때문에 마이크로쓰레드[* OS가 직접 관리하는 쓰레드가 아닌, 유저 프로세스 차원에서 직접 돌리는 쓰레드. 그린 쓰레드(green thread)라고도 하는데 [[Ruby]] 1.8까지 지원하는 쓰레드가 바로 이것이다.]나 [[코루틴]] 같은 기능들을 쓸 수 있게 됐고, 덕분에 쓰레드도 [[고자]]고 코루틴도 안되는 CPython에 비해 동시성 처리에서 훨씬 강력한 이득을 낼 수 있게 됐다. CPython도 3.4 버전 이후로 코루틴을 지원한다. 아래 멀티쓰레딩 섹션 참조.\n\n다만, 앞서 말했듯이 CPython을 개조한 것이기 때문에, 파이썬의 버전이 올라갈 때마다 개조한 코드가 이상없이 동작하는지 항상 확인해야 하고, 이 기능이 운영체제나 하드웨어에도 영향을 받는 까닭에 심하면 각각의 운영체제나 CPU별로 개발을 따로 해야 하는 피곤한 작업을 Python이 망할 때까지 해야 하는 지겨운 길을 걷게 되는 것이었다. 그래서 실제로 한동안 Stackless Python의 개발이 잠시 중단된 일도 있었을 정도.\n\n그런 와중에 [[PyPy]] 리드 개발자 Armin Rigo가 \"C 호출 스택도 어차피 메모리에 있잖아? '''그러면 그걸 'memcpy()'로 통째로 복사하고 덮어 씌우면 호출 스택을 저장하고 복구하는 거 아냐?'''\"라는 실로 마개조스러운 아이디어를 내놓는데, Christian Tismer가 여기에 매우 깊은 감명을 받고 Armin Rigo와 함께 구현한 결과 [[http://pypi.python.org/pypi/greenlet|greenlet]]이라고 하는 '''import만 하면 [[코루틴]]을 쓸 수 있는 모듈'''을 만들어내기에 이른다. 같은 걸 구현하려고 언어 인터프리터 자체를 뜯어 고치는 수고에 비하면 놀랄 만큼의 노력 절약이 아닐 수 없다. 다만 이 짓을 제대로 구현한 Stackless Python에 비하면 아무래도 성능이 딸리기 때문에 정말 절실하게 성능이 필요한 [[EVE 온라인]]과 같은 경우엔 Stackless Python을 쓴다.\n\n하지만... Armin Rigo와 Christian Tismer는 지금 둘 다 [[PyPy]]를 만들고 있고, PyPy는 자체 스택을 쓸 수 있는 Stackless 모드의 '''[[JIT|JIT 컴파일러]]'''를 만들어낼 수 있다.\n\n=== [anchor(cython)]C 언어 확장, Cython ===\n--싸이썬-- --[[싸이|Psy]]son--\nPython의 속도를 높이고자 아예 C언어로 변환하여 컴파일하는 방법을 택한 패키지. 파이썬의 문법을 확장하여 정적 타입 선언 기능을 넣어, 기존의 C 코드를 쉽게 접착할 수 있도록 만들었다. Python C API를 이용하여 C 코드를 직접 접착하는 기존의 방식보다 훨씬 사용하기 쉽고, C언어로 변환되어 컴파일 된다는 점 때문에 ctypes로 덧씌우는 것 없이 네이티브 코드(*.so, *.dll)를 직접 사용할 수 있다. 이것을 사용하면 적게는 열 배 정도에서 많게는 천 배 이상까지 속도 향상을 경험할 수 있다. (물론, 파이썬과 C의 구현 차이를 잘 이해하고 컴파일이 제대로 동작할 수 있게하기 위한 코드 수정이 요구된다. 그냥 냅다 넣고 돌려버리면 제기능을 제대로 발휘하지 못하거나 심지어는 거의 발전이 없는 경우도 생길 수 있다. 프로파일링은 언제 어디서나 기본이다.)\n\nC를 모르는 상태에서 Cython을 사용하는 것이 아예 의미가 없는 것은 아니지만, C와 Python 둘 모두에 익숙할 때 Cython을 가장 효과적으로 쓸 수 있다. 고성능이 필요하면 일단 코드 수정이 불필요한 [[PyPy]]를 시도하고, 그걸로는 만족스럽지 않을 때 외부 라이브러리를 도입해 보고, 그걸로도 부족할 때 고려해보자. Cython의 대안으로는, SWIG, CFFI(C Foreign Function Interface), pybind(C++ 전용) 등의 도구들이 있다.\n\n참고로, PyPy도 Cython에 크게 밀리지 않을 정도로 속도가 빠르고, PyPy를 사용하여 실행했을 때 속도 향상이 별로 없다면 Cython을 사용하여 C로 변환해도 상황이 비슷한 경우가 많다. Cython을 사용하여 속도 향상 효과를 얻고자 한다면, 파이썬 코드를 바로 실행할 수 있는 PyPy를 사용하여 속도를 미리 체크해보는 것이 유용한 방법이 될 수 있다.\n\n=== [anchor(pyston)]C++ 구현, Pyston (프로젝트 중단) ===\nPyston은 [[LLVM]] 컴파일러를 사용한다. Pyston은 [[JIT]]([[just-in-time]]) [[컴파일러]]를 내장하여 반복되는 [[소스 코드]]를 빠르게 실행할 수 있다.\n\n2014년 4월 프로젝트가 시작되었으며, Python 2.7 호환, x86 64비트 플랫폼을 목표로 개발 중에 있다. [[https://blogs.dropbox.com/tech/2014/04/introducing-pyston-an-upcoming-jit-based-python-implementation/|Dropbox Tech Blog - Introducing Pyston: an upcoming, JIT-based Python implementation (April 3, 2014)]]\n\nPyston은 [[C++]]로 작성되어졌다. [[https://github.com/dropbox/pyston/wiki/Technical-overview|Technical overview · dropbox/pyston Wiki · GitHub (1 Sep 2016)]]\n\n[[우분투]]에서만 테스트되고 있다. 그러다가 2017년 1월 31일부로 [[Dropbox]]에서 공식적으로 스폰싱을 종료했다. [[https://blog.pyston.org/2017/01/31/pyston-0-6-1-released-and-future-plans/|Pyston 0.6.1 released, and future plans (January 31, 2017)]] 메인테이너가 Dropbox 직원인데 더 이상 참여를 못하는 사실상 프로젝트 중단이다. 직후 프로젝트 리더였던 Kevin Modzelewski는 퇴사하였다.\n\n성능은 상당히 훌륭한 편이었으나, CPython과의 호환성을 오랫동안 맞추지 못했고, 프로젝트가 시작됐을 때와 다르게 Dropbox의 코드가 Go랑 Python3로 많이 이전된 것이 원인으로 보인다(즉, 굳이 투자하면서 개발을 지속할 이유가 없는 상황). 또한 곧 Python2 버전이 공식적으로 지원이 중단될 예정이라서 완전하게 돌아가게 되는 시점(이조차 아무도 알 수 없었다)에서 이 프로젝트의 의미가 많이 퇴색될 수밖에 없었던 것.\n\n[[Dropbox]]는 [[Pyston]]에서 [[PyPy]]로 옮겼다가 현재는 [[Go(프로그래밍 언어)|Go]]를 쓰고 있다. [[https://blogs.dropbox.com/tech/2014/07/open-sourcing-our-go-libraries/|Dropbox Tech Blog: Open Sourcing Our Go Libraries (July 1, 2014)]]\n\n[[https://github.com/dropbox/pyston|홈페이지]]\n\n=== Python 구현, PyPy ===\n[include(틀:상세 내용, 문서명=PyPy)]\nPython으로 Python을 만드는 프로젝트. JIT 컴파일을 사용하기 때문에 훨씬 빠르다.\n\n=== [anchor(jython)]Java 구현, Jython ===\nJython은 [[Java]]로 구현되어 [[Java Virtual Machine|JVM]] 위에서 실행된다. [[https://github.com/jythontools/jython|#]] CPython이 C언어와 결합성, 접착성이 좋은 것처럼 Jython은 Java와 결합성이 대단히 좋으며, 실제로 Java 진영의 메이저 업체인 [[오라클(기업)|Oracle]], [[IBM]] 등에서도 자사 제품에 Jython을 내장하여 스크립팅 기능을 제공하고 있을 정도다.\n\nJython은 [[Java Virtual Machine|JVM]] 위에서 실행되며, Python Module이 제공하는 API는 물론이고, [[JDK]]가 제공하는 모든 API를 그대로 사용할 수 있다. 오히려 pycrpyto와 같이 C언어로 구현된 CPython 모듈은 Jython에서 사용할 수 없다. 그러나 일단 Java Class라면, 설령 JNI로 되어있어서 C로 작성된 동적 모듈(*.dll, *.so 등)을 사용한다고 해도 Jython에서 사용하는데 아무런 제약이 없다. 또한 JVM 위에서 실행된다는 점 때문에 CPython의 GIL이 이식 되지 않았으며, CPython이 멀티스레드에서 보이는 단점이 Jython에는 존재하지 않는다. threading, threadsafety 등의 Python에서 제공하는 멀티스레드(락, 동기화 관련) 기능이 마음에 들지 않으면 java.util.concurrent에서 제공하는 Java API를 사용하면 된다!\n\n=== [anchor(ironpython)].NET Framework 구현, IronPython ===\nMicrosoft [[.NET#Framework|.NET Framework]]의 가상머신인 CLR 상에서 구현되고 이 위에서 동작하는 Python이다. 정확히 말하면 이들 동적언어를 CLR 위에서 구현하기 위한 DLR이라는 프레임워크 기반이다. 제작자 Jim Hugunin[[https://en.wikipedia.org/wiki/Jim_Hugunin|#]]은 [[Jython]]의 제작자이며, [[NumPy]]의 전신인 Numeric 라이브러리의 제작자이기도 하다. 따라서 당연히 .NET Framework 환경에서 제작된 DLL과 결합성이 매우 좋다. Jython과 마찬가지로 병렬 프로그래밍 환경에서 GIL 때문에 고민할 필요가 없다.\n\n자매품으로는 [[C\\#]]로 작성된 모듈을 마치 파이썬 모듈처럼 임포트해서 쓸 수 있는 [[https://github.com/pythonnet/pythonnet|Python for .NET]]이 있으며 이 경우에는 CPython 위에서 돌아간다.\n\n=== [anchor(brython)]JavaScript 구현, Brython ===\n[[JavaScript]]로 구현되었고, JavaScript를 대신하여 웹 브라우저에서 스크립트 형태로 Python을 실행할 것을 목적으로 하는 'Brython'이 있다. Python3를 구현했으며, 다음과 같이 script 태그의 type을 text/python으로 지정하여 실행할 수 있다.\n\n{{{#!syntax python\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Brython</title>\n  <script src=\"brython.js\"></script>\n</head>\n<body onload=\"brython()\">\n  <input id=\"zone\"><button id=\"mybutton\">click!</button>\n\n  <script type=\"text/python\">\n    from browser import document, alert\n\n    def echo(ev):\n        alert(document['zone'].value)\n\n    document['mybutton'].bind('click', echo)\n  </script>\n</body>\n</html>\n}}}\n\n==== 자바스크립트로 컴파일 transcrypt ====\n[[http://www.transcrypt.org|홈페이지]]\n\n[[타입스크립트]]와 비슷한 방식으로 파이썬 코드를 자바스크립트로 컴파일해서 일반적인 자바스크립트와 혼합하여 사용할 수 있게 해준다. (Ex. 파이썬 + [[jQuery]])\n\n=== Micro Python ===\n[[https://micropython.org/|홈페이지]]\n[[https://micropython.org/unicorn/|공홈에서 제공하는 웹에뮬레이터]]\n\n파이썬3의 기능을 임베디드 보드에 최적화 하여 구현한 프로그래밍 언어이다. Windows OS와 Windows Embeded OS와의 관계를 생각하면 이해하기 쉽다. 국내에서는 주로 마이크로비트보드에서 사용할 목적으로 많이 사용된다. 카시오 FX-9860 GIII에 탑제되어 있기도 하다.\n\n== 생태계 ==\n\n=== 개발 환경 ===\n * 콘솔\n 윈도우 명령 프롬프트나 리눅스 Bash 같은 곳에서 실행하는 콘솔형 파이썬 인터프리터다. 여기서도 충분히 간단한 코딩을 할 수 있고, 콘솔 상에서도 pretty printer를 이용해 다양한 자료 구조를 ASCII Art로 출력해 주는 기능까지 이용해볼 수 있다.\n  * IDLE\n  파이썬 기본 탑재 콘솔로, 순수 파이썬으로 작성되었다. 콘솔과 같이 직접 명령을 입력하는 것 외에도 파이썬 스크립트를 직접 편집할 수 있으며, 문법 강조와 디버깅 등의 기능을 지원한다. 파이썬에 입문하는 경우에는 따로 텍스트 에디터를 설치할 필요 없이 IDLE만으로도 충분하다.\n  * IPython\n  오픈 소스 라이브러리로, 파이썬 IDLE와 달리 LaTeX나 svg, Matplotlib의 플롯 같은 것들도 출력해준다. {{{_repr_}}}이라는 특수 prefix가 붙은 메서드들을 클래스에 정의해 놓으면 IPython의 출력 기능과 쉽게 통합시킬 수 있다. 후술할 Jupyter의 백엔드로도 쓰인다.\n\n==== 텍스트 에디터 ====\n문법 강조와 자동 들여쓰기 등의 편의 기능을 제공하는 프로그램. 메모장보다는 기능이 많고 [[IDE]]보다는 기능이 부족한, 중간 정도의 에디터라고 보면 된다.\n\n[[IDE]]보다 기능은 부족한 대신 로딩 속도가 빠르고, 자잘한 버그가 없기 때문에 개인 취향이나 프로젝트 성격에 따라 이쪽을 더 선호하기도 한다. 파이썬 문법은 C나 Java처럼 Boilerplating이 별로 없기 때문에 IDE의 자동 완성 기능이 상대적으로 덜 중요하다. 개중에는 플러그인을 설치하여 IDE 못지않은 기능을 추가할 수 있는 경우도 있다.\n\n * [[Notepad++]]\n * [[Sublime Text]]\n * [[Atom(에디터)|Atom]]\n * [[비주얼 스튜디오 코드|Visual Studio Code]]: Python 전용 플러그인을 설치하면 더 많은 기능을 이용할 수 있다.\n\n==== [[통합 개발 환경|통합 개발 환경(IDE)]] ====\n * [[PyCharm]]\n [[JetBrains]] 사에서 개발한 IDE로, 코드 컴플리션 기능이 우수하고 각종 프레임워크 지원이 가장 뛰어나다. 커뮤니티 에디션은 무료이지만 [[Django]] 같은 웹 개발에 도움이 되는 툴을 쓰려면 프로페셔널 에디션을 사용해야 한다. 프로페셔널 에디션이 없더라도 플러그인 등을 통해 기본적인 html/javascript 문법지원과 기본적인 자동완성은 가능하지만, Django 전용 자동완성(예를 들어 템플릿에서 파이썬 변수명을 자동완성해 준다던지), 실시간 렌더링 등의 기능은 사용할 수 없다.\n * Spyder\n 오픈 소스 IDE로 [[PyCharm]] 프로페셔널 에디션 같은 툴을 쓰기 힘든 학생[* PyCharm 프로페셔널은 대학생한테는 무료이다]이나 개인 개발자가 사용할 만한 대안이다.\n * [[비주얼 스튜디오|Visual Studio]]\n 가장 무거운 개발 툴이지만 Breakpoint를 설정해 디버깅을 할 수 있거나, Variable Explorer을 가지고 있거나, Profiler를 가지고 있는 등 기능이 다양해서 충분한 값어치를 할 수 있으면 쓰는 것이 좋다. 그 외에도 파이썬으로 프로그래밍에 입문하는 사람들에게도 설치가 쉽다는 점에서 추천하는 편이다.\n\n==== Notebook ====\n다소 특이한 개발 환경으로, 스타일 있는 문서 양식에 코딩을 접목시킬 수 있다. 블로그나 노트를 쓰듯이 단락을 만들고, 그 안에 Cell을 만들어서 코드를 적어놓고, 실행시키면 Plot 같은 것을 보여줄 수 있다.\n\n물론 이런 것이 무슨 프로그래밍인가 싶긴 하지만, 데이터 사이언스나 데이터 분석과 같은 분야는 완성된 시스템을 만들기보다, 파이썬 코드로 데이터를 어떻게 처리하면 되는지 프로토타입을 만들고 그것을 가지고 리포트를 쓰거나 프리젠테이션을 하는 일이 많기 때문에 많이 사용한다. 즉 이들에게는 하나의 완성된 프로그램을 만드는 것이 아니라 데이터를 이리저리 돌려보며 코딩 → 결과 확인 → 코드 수정 → 결과 확인 등의 반복적인 작업이 중요하기 때문이며, 데이터 시각화와 같은 분야에서도 코드를 셀 단위로 나누어 반복 수정하는 작업을 하는 데에 있어서 매우 유용하기 때문이다. SymPy, NumPy, SciPy, Matplotlib 같은 수학, 과학, 머신 러닝 라이브러리를 자주 이용하는 환경에서 개발할 때 유용한 편이며, pandas 등의 라이브러리를 사용하여 데이터 분석을 하는 데도 많이 사용한다.\n\n사실상 데이터 분야에서 Notebook은 업계 표준과 같은 취급이며, 이 때문에 Google의 Colaboratory나 MS의 Azure Notebook과 같은 클라우드 기반의 데이터 분석 환경 역시 jupyter notebook을 모방하거나 탑재하고 있다.\n \n공부하는 입장에서 스크립트 파일을 일일이 만들어야 하는 통상적인 개발 방식이 번거롭게 느껴진다면 차라리 Notebook을 이용해 각종 알고리즘을 연습해 보는 것이 좋다. 다만 파일이 단순한 스크립트 파일이 아니라 거진 워드 문서 같은 수준이 되어 버리기 때문에 (Plot 같은 것을 바이너리 형태로 저장해야 하기 때문이다) 용량이 커지고 Git과 궁합이 맞지 않게 된다는 점은 단점이다. 또한 최소 천 줄이 넘어가는 프로젝트는 노트북으로 하면 안 된다. 노트북은 프로토타이핑이나 리포트를 쓰는데에나 활용하고 진짜 개발은 파이썬 스크립트 파일을 작성해 하도록 하자.\n \n  * ipython[* 터미널 기반의 노트북 환경 인터프리터. 기존의 인터프리터와 구분되는 UI를 가지고있다. 주피터 노트북은 ipython이 웹브라우저 기반으로 작동하는 것]\n  * Jupyter Notebook[* 알 수 없는 이유로 실행버튼을 눌러도 스크립트가 전혀 실행되지 않고 별표만 띄우는 일이 종종 있다. 이게 걸려버리면 기존에 정상적으로 실행된 스크립트를 다시 실행시키면 별표만 나온다. ~~보통 입문자들이 코드를 이상하게 짜면 저리 되는데, 신기한 건 에러도 안 뿜고 별표만 띄우고 뻗어버린다는 거다.~~ 커널을 리셋하면 해결되긴 하는데 머지않아 또 뻗기도 한다. 밑에 있는 구글 콜라보는 이게 좀 덜한 편.]\n  * JupyterLab[* 주피터 노트북의 상위호환 버전. 인터페이스 부분이 노트북에 비해 개선되어 더 깔끔해졌다. 테마나 터미널 설정도 가능해 눈이 편하다. 이전의 노트북을 더 선호하는 사람도 있는 편.]\n  * [[https://colab.research.google.com/|Google Colaboratory]][* 구글에서 제공하는 주피터 노트북 환경으로. 별도의 설치가 전혀 필요없다. 심지어 휴대폰에서도 돌아간다! 대형 프로젝트가 아닌 간단한 문제풀이나 데이터 분석 용도로 사용할 수 있다. 다만 첫 실행의 경우 실행속도가 다소 느릴 수 있다. 인터넷에 연결된 상태에서 철저하게 웹 위에서 돌아가는지라 본인 컴퓨터에 없는 모듈도 즉석에서 받아 실행시킬 수 있다. 만들어진 노트 파일은 본인의 구글 드라이브에 저장된다.]\n\n==== 패키지 관리 ====\n각종 파이썬 라이브러리를 설치하고 관리하는 도구이다. 몇몇 파이썬 라이브러리는 리눅스의 패키지 관리자로도 설치할 수 있지만, 파이썬 패키지 관리에 특화된 Pip이나 Conda를 사용하는 것이 이후 패키지를 관리할 때 편리하다. 쓸데없는 라이브러리들이 함께 설치되거나 패키지 의존 관계가 꼬이는 것을 막으려면 하나의 패키지 관리자만 이용하는 것이 좋다.[* 단, Conda에는 등록되지 않아서 Pip으로만 설치할 수 있는 패키지는 어쩔 수 없이 Pip을 사용해야 한다.]\n\n * Pip\n 파이썬의 기본 패키지 관리자이다. 기본적으로 패키지를 모두 한 곳에 설치하기 때문에 시스템에 내장된 파이썬에 영향을 주며, 프로젝트를 여러 개 관리할 경우 호환성 문제가 생긴다. 따라서 virtualenv나 venv와 같이 가상 환경을 다루는 도구와 함께 사용하는 것이 좋다.\n * virtualenv\n 파이썬 가상 환경 관리자로, 패키지를 마음대로 설치할 수 있는 가상 환경을 생성한다. 각 프로젝트마다 자신이 사용할 가상 환경을 만들어주면 프로젝트마다 필요한 패키지를 따로 설정해주는 것이 가능하다.\n \n * Anaconda\n Conda라는 패키지 관리자 + 가상 환경 관리자를 제공하며, 수학/과학/공학 업무에 필요한 NumPy, SciPy, Jupyter Notebook 등의 수백 개의 패키지와 도구를 한번에 깔아줄 뿐만 아니라 GUI도 제공한다. 그래서 통계나 데이터 사이언스, 인공지능 등의 분야 쪽 파이썬 입문자들에게 추천하는 편이다. 다만 설치에 시간이 오래 걸리고, 어차피 몇백 개나 되는 패키지를 다 쓸 일은 없기 때문에 Conda 사용에 숙련되면 아래에 나온 Miniconda를 쓰는 것도 좋다. 2020년 부터 정부 및 200인 이상 기업에게는 유료로 바뀌었다. \n\n * Miniconda\n 위의 Anaconda와 기본 기능은 동일하지만, 패키지는 자기가 직접 찾아서 깔아야 한다. 하지만 어차피 필요한 패키지를 설치하는 것은 {{{#conda install <패키지명>}}} 몇번만 두드려 보면 간단히 해결된다. 이것도 아나콘다의 변형이라서 정부 및 200인 이상 기업에게는 유료.\n\n==== 코드 검사 ====\n내가 작성한 파이썬 코드가 잘 쓰였는지 검사하는 도구. 파이썬은 다른 언어에 비해 문법 규칙이 일관적이지만, 한 줄의 길이나 문자열을 감싸는 따옴표({{{\"\"}}}/{{{''}}}) 등 개발자 입장에서 논쟁거리가 될 만한 요소는 많다. 따라서 코딩 스타일을 통일하는 도구를 사용하면 여러 사람이 협업하면서 생기는 코드의 가독성 문제를 개선할 수 있다. 또한 코딩하는 중에도 오류나 바람직하지 않은 코드를 잡아낼 수 있는 편리한 기능을 제공하는 도구를 사용하면 버그를 일찍 잡아내고 테스트에 드는 노력을 줄일 수 있다.\n\n코드 검사 도구의 한 갈래로 자료형 검사 도구(type checker)가 있다. 동적 언어라서 변수의 자료형을 따로 체크하지 않는 파이썬을 위해, 코드를 직접 분석하여 변수를 올바른 용도로 사용하는지, 특정 함수에 올바른 값을 전달하는지와 같은 정보를 검사한다. 비슷한 동적 언어인 [[JavaScript]]에 자료형 검사를 제공하는 [[TypeScript]]와 유사하지만, 컴파일이 필요한 TypeScript와 달리 Python은 언어 차원에서 type hint를 허용하기 때문에[* 단, 허용할 뿐이지 파이썬이 스스로 자료형을 검사하지는 않는다. Type hint는 다른 도구가 읽고 분석하기 위한 용도이다.] type hint를 추가한 코드도 그대로 실행이 가능하다.\n\n * 코드 오류 검사\n  * [[https://www.pylint.org/|Pylint]]: Python 코드를 검사하여 오류나 바람직하지 않은 문법을 잡아내는 도구이다.\n  * [[https://flake8.pycqa.org/|Flake8]]: Pylint에 비해 덜 꼼꼼한 대신 더 빠르다.\n * 자료형(타입) 검사\n  * [[http://mypy-lang.org/|MyPy]]: 파이썬을 위한 자료형 검사 도구의 원조로, 순수 Python으로 작성되었다.\n  * [[https://pyre-check.org/|Pyre]]: [[페이스북]]에서 만든 자료형 검사 도구로, [[Ocaml]]로 작성되었다.\n  * [[https://github.com/microsoft/pyright|Pyright]]: [[마이크로소프트]]에서 개발한 자료형 검사 도구로, [[TypeScript]]로 작성되었다. Visual Studio Code 플러그인을 정식 지원하며, 플러그인이 아닌 명령줄 도구로 사용하려면 [[Node.js]]를 설치해야 한다.\n  * [[https://google.github.io/pytype/|Pytype]]: [[구글]]에서 만든 자료형 검사 도구이다.\n * 코딩 스타일 검사 및 수정\n  * [[https://github.com/hhatto/autopep8|autopep8]]: 파이썬 공식 스타일 가이드인 [[https://www.python.org/dev/peps/pep-0008/|PEP 8]]에 맞게 코드를 고쳐준다.\n  * [[https://github.com/google/yapf|yapf]]: [[구글]]에서 개발한 스타일 검사 도구.\n  * [[https://black.readthedocs.io/|Black]]: 다른 스타일 검사 도구에 비해 매우 엄격한 것이 특징으로, '''코딩 스타일에 대해 아예 논쟁을 못하게 한 가지 스타일을 강요한다'''는 컨셉을 고수한다. 이 때문에 다른 검사 도구에 비해 설정할 수 있는 옵션의 갯수가 매우 적다. 내가 원하는 코드 스타일이 아니라 Black이 강요하는 스타일을 따라가야 한다는 단점이 있지만, 대신 Black으로 처리한 코드는 누가 쓰든 비슷비슷해서 금방 익숙해진다. 개발자가 신경써야 할 것을 최소화한다는 점 덕분에 후발주자임에도 빠르게 인기를 얻었다.\n  * [[https://timothycrosley.github.io/isort/|isort]]: import 문을 일관성 있게 정렬해 준다.\n\n=== [anchor(library)]라이브러리 ===\n * 뷰티풀 수프(Beautiful Soup): XML, HTML와 같은 구문 트리 또는 구조화된 데이터 처리를 위한 [[라이브러리]]이다.\n * [[https://dateutil.readthedocs.io/|dateutil]]: 복잡한 날짜 및 시간 형식을 다루는 라이브러리이다. 표준 라이브러리에 포함된 [[https://docs.python.org/3/library/datetime.html|datetime]]만으로 해결하기 어려운 날짜/시간 문자열 처리나 국제 시간에 관련된 기능을 제공한다.\n * 필로우(Pillow): PIL은 개발이 예전에 중지되었고, PIL의 [[포크]](fork)인 Pillow가 그 역할을 대신하고 있다. Pillow를 쓰자. PIL은 Python Imaging Library의 머릿글자로 간편한 이미지 처리를 위한 라이브러리이다.\n * [[https://pyyaml.org/|PyYAML]]: [[YAML]] 형식의 파일을 읽고 쓰기 위해 사용하는 라이브러리이다.\n * [[https://requests.readthedocs.io/|requests]]: HTTP 요청을 보낼 때 사용하는 라이브러리이다. 표준 라이브러리에 내장된 [[https://docs.python.org/3/library/urllib.html|urllib]] 모듈에 비해 사용이 편리하고 기능이 뛰어나다.\n * [[https://github.com/what-studio/tossi|tossi]]: [[야생의 땅: 듀랑고]]를 개발한 왓 스튜디오에서 개발한 한국어 조사 처리 라이브러리. 같은 인물이 만든 korean 모듈을 대체했다.\n * [[https://docs.python.org/ko/3/library/argparse.html|argparser]] 터미널에서 명령어 parser 지원 [[https://kibua20.tistory.com/120|예제]]\n\n==== 수학 ====\n범용성을 지닌 [[수학]] 라이브러리들\n * 심파이(SymPy): 인수 분해, 미분, 적분 등 심볼릭 연산 기능을 제공한다.\n * [[NumPy|넘파이]](NumPy): 통계, 선형 대수, 행렬 계산, 금융 운용 등을 포함한 과학 계산과 수학 작업. 수치 해석, 특히 선형 대수(linear algebra) 계산 기능을 제공하며 자료형이 고정된 다차원 배열 클래스(n-dimensional array)와 벡터화 연산(vectorized operation)을 지원한다. 참고로 Numpy는 C언어로 제작되어, 파이썬 답지 않은 넘사벽 수준의 속도를 자랑한다. 꼭 수치해석/선형대수 목적이 아니더라도 배열형태의 데이터에 대한 처리속도를 간단하게 높이는 야매 수준으로 사용할 수 있다.\n * 싸이파이(SciPy): 고성능 선형대수, 함수 최적화, 신호 처리, 특수한 수학 함수와 통계 분포 등 과학 계산용 함수를 모아놓은 파이썬 패키지이다. 고급 수학 함수, 수치적 미적분, 미분 방정식 계산, 최적화, 신호 처리 등을 위한 다양한 과학 기술 계산 기능이 제공된다.\n\n==== 데이터 ====\n[[빅 데이터]], [[통계학]] 라이브러리.\n * [[pandas|판다스(pandas)]]: [[데이터 처리]]와 분석을 위한 라이브러리이다. 테이블 형태의 데이터를 다루기 위한 데이터프레임(DataFrame) 자료형을 제공한다. [[R(프로그래밍 언어)|R]]의 data.frame을 본떠서 설계한 DataFrame이라는 데이터 구조를 기반으로 만들어졌다. [[https://jalammar.github.io/visualizing-pandas-pivoting-and-reshaping/|Visualizing Pandas' Pivoting and Reshaping Functions]] 참조.\n * 다스크(Dask) : [[https://dask.org/|홈페이지]] 판다스의 병렬&분산처리 버전. 판다스랑 사용법이 거의 같으면서도 드라마틱하게 빨라진다. 다만 아직 갈 길이 먼 것이 흠.\n * StatsModels: [[통계]] 및 [[회귀 분석]], [[시계열 분석]]을 위한 라이브러리이다.\n\n==== 그래프 (차트) 그리기 ====\n수학이나 데이터의 시각화를 전문적으로 하는 라이브러리\n * 맷플랏립(matplotlib): 과학 계산용 그래프 라이브러리. Tkinter, wxPython, [[Qt(프레임워크)|Qt]], GTK+ 등의 그래픽 엔진을 사용할 수 있으며 그래프와 챠트 등을 그리기 위한 시각화 기능을 제공한다. pylab이라는 서브패키지를 제공하여 [[MATLAB]]의 그래프 기능을 거의 동일하게 사용할 수 있다.\n * 씨본(Seaborn): matplotlib에서 지원하지 않는 고급 통계 차트를 그리기 위한 통계용 시각화 기능을 제공하는 시각화 라이브러리이다.\n * [[보케#python]](Bokeh): 주피터 노트북이나 웹상에서 자바스크립트로 그래프나 차트를 그려주는 기능을 제공해준다.\n * Pygal: 시각화 라이브러리이다.\n\n==== [anchor(libraryml)]머신 러닝 ====\n머신 러닝, 딥 러닝 전문 라이브러리\n * [[텐서플로우]]([[TensorFlow]]): 구글에서 오픈 소스로 공개한 [[기계 학습]], 인공 신경망 라이브러리이다. \n * 사이킷런(scikit-learn): 파이썬의 [[머신 러닝]] 라이브러리이다.\n * [[파이토치]]([[https://github.com/pytorch/pytorch| PyTorch]]): 토치 기반의 기계 학습 라이브러리. 간결하고 구현과 성능이 빠르며, TensorFlow보다 사용자가 익히기 훨씬 쉽다. 학계에서는 2017년부터 이미 파이토치가 텐서플로우보다 더 많이 언급되고 있다.\n * 케라스(Keras): TensorFlow, Theano, CNTK 등 [[딥 러닝]] 라이브러리를 백엔드로 사용할 수 있어 쉽게 다층 퍼셉트론 신경망 모델, 컨볼루션 신경 망 모델, 순환 신경망 모델, 조합 모델 등을 구성할 수 있다. TensorFlow 등 다른 라이브러리에 비해 쉬운 문법이 특징. 현재는 TensorFlow와 통합되었다.\n\n==== [anchor(gui)]GUI 프로그래밍 ====\n파이썬에서 [[GUI]] 프로그래밍에 가장 많이 쓰이는 것은 파이썬에 기본으로 포함된 Tkinter이지만 그 외에도 [[wxWidgets|wxPython]], [[Qt(프레임워크)#s-9.1|PyQt]], [[https://doc.qt.io/qtforpython/| PySide]][* PySide2를 Qt for Python에서 공식적으로 지원하고 있다.], PyGTK, [[SFML]], pyglet도 쓰인다. 브라우저에서 실행되는 javascript와 python 함수 호출 간의 경계를 거의 깨주는 eel을 사용하면 웹 기술을 사용해 GUI 프로그래밍을 할 수 있다.\n\n===== [anchor(tkinter)]tkinter =====\ntkinter는 Tk interface의 약자이다. Tk는 [[GUI]] 프로그래밍을 위한 [[라이브러리]]이다. Tcl은 프로그래밍 언어로 Tk와 함께 GUI에 쓰인다.\n\n===== [[https://doc.qt.io/qtforpython/|Qt for Python]] =====\nPySide2 모듈을 기반으로 Qt5 애플리케이션을 파이썬으로 작성할 수 있도록 [[Qt(프레임워크)#s-9.1]] 측에서 공식적으로 지원하고 있다.\n\n=== 프레임워크 ===\n==== 웹 프레임워크 ====\nPython은 [[웹 서버]][* 하드웨어인 서버 컴퓨터가 아니라, 그 위에서 돌아가는 소프트웨어를 말하는 것이다. 웹 서버는 네트워크 요청을 받아 웹 어플리케이션이 처리할 수 있는 형태로 만들어 넘겨주며, 소켓이나 프로세스 풀과 같은 자원을 관리한다.]와 웹 어플리케이션(프레임워크) 간의 호환을 위해 크게 두 가지 규격을 제시하고 있다. 하나는 Java의 서블릿을 모방한 [[https://wsgi.readthedocs.io/|WSGI]]이고, 다른 하나는 비동기형(async/await) 프로그래밍을 위해 만들어진 [[https://asgi.readthedocs.io/|ASGI]]이다. 웹 프레임워크와 웹 서버를 선택할 땐 서로 호환이 되는지 확인해야 한다. 이 외에도 자체적으로 웹 서버를 제공하거나 독자적인 규격을 사용하는 프레임워크도 있다.\n\n * WSGI 기반 (동기형)\n  * [[Django]]: 풀 스택 [[웹 프레임워크]]. 정식으로 비동기 프로그래밍이 가능한 것은 아니지만 ASGI 서버와도 부분적으로 호환이 된다.\n  * [[Flask]]: 마이크로 웹 프레임워크. 가볍고 간단한 서비스를 만들기 좋으나, 복잡한 기능은 모두 플러그인을 설치해야 한다.[[https://kibua20.tistory.com/110|사용방법]]\n  * [[https://bottlepy.org/|Bottlepy]]\n * ASGI 기반 (비동기형)\n  * [[https://www.starlette.io/|Starlette]]\n  * [[https://fastapi.tiangolo.com/|FastAPI]]: Starlette에 데이터 검사 라이브러리인 Pydantic을 얹고 이런저런 유용한 기능을 추가한 프레임워크로, [[API]] 서버를 빠르게 개발하는 데 알맞다.\n\n==== 그 외 ====\n * [[Pygame]] - 파이썬으로 비디오 게임을 제작하기 위한 [[프레임워크]]이다.\n * [[https://scrapy.org/| 스크래피(Scrapy)]]: 웹 스크래핑 및 크롤링\n\n== 관련 팁 ==\n * 문자열을 합칠 때 join을 쓰자. range 함수와 str 함수를 같이 쓰면 매우 편해지는 경우가 있다.\n  {{{#!syntax python\n''.join(str(x) for x in range(10))\n}}}\n\n * 슬라이스(slice) 문법은 리스트/문자열의 부분을 잘라내는 것 이외에도 다양한 활용이 가능하다.\n  {{{#!syntax python\n# 문자열 뒤집기\na = 'abc'\nprint(a[::-1]) # 출력: cba\n\n# 리스트 복사\na = [1, 2, 3]\nb = a[:]\nprint(b)      # 출력: [1, 2, 3]\nprint(a is b) # 출력: False\n\nc = [[1, 2], [3, 4]]\nd = c[:]\nc[0] = [5, 6] # 리스트 자체는 복사되지만\nc[1][0] = 7   # 리스트의 원소들까지 복사되지는 않으므로 주의해서 사용하자.\nprint(c)      # 출력: [[5, 6], [7, 4]]\nprint(d)      # 출력: [[1, 2], [7, 4]]\nprint('%s, %s, %s' % (c is d, c[0] is d[0], c[1] is d[1])) # 출력: False, False, True\n}}}\n\n * 숫자, 문자, 튜플은 변경 불가능(immutable)하며, 리스트, 집합, 딕셔너리는 변경 가능(mutable)하다. 이때 '''변경 가능한 자료형은 다른 변수에 대입하여도 그 내용이 공유된다.''' 그 예로, 아래와 같은 코드가 있다고 하자.\n  {{{#!syntax python\na = (1, 2, 3)\nb = a\nb += (2, 1)\nprint(a) # 출력: (1, 2, 3)\nprint(b) # 출력: (1, 2, 3, 2, 1)\n}}}\n  우리가 예상한 대로, 튜플 b만 변경되고, a는 변경되지 않는다. 위의 코드에서 튜플(immutable)을 리스트(mutable)로 바꾸어 보자.\n  {{{#!syntax python\na = [1, 2, 3]\nb = a\nb += [2, 1]\nprint(a) # 출력: [1, 2, 3, 2, 1]\nprint(b) # 출력: [1, 2, 3, 2, 1]\n}}}\n  출력을 보면 b만 변경했음에도 a가 변한다는 사실을 알 수 있다. 이것은 모든 변경 가능한 자료형에 적용되며, '''심지어 리스트 안의 리스트 같은 것들까지도 공유가 된다.''' 그러니 원본을 변경하면 안 되는 경우에는 list(), set(), dict()나 copy 모듈 등을 이용해서 객체를 복제하고 작업하자. 변경 불가능한 자료형은 원본을 변경할 수 없기 때문에 해당사항이 없다.\n  특히 list나 dict 자체를 함수에 인자로 전달받을 때 내부에서 리스트를 변형하는 연산을 하면 함수 밖에서도 list나 dict가 변형되니 주의하도록 하자.\n\n * list.insert(0) 와 list.append()는 각각 첫번째 자리에 값을 추가하거나, 마지막 자리에 값을 추가하는 정도의 조그만한 차이일 뿐이지만, 계산 시간이 O(N)과 O(1) 수준으로 차이가 나기 때문에 첫번째 방법은 쓰지 않는 것이 좋다.\n 그래서 prepending에 의존하는 하는 알고리즘을 파이썬 리스트로 구현하려면, 알고리즘을 거꾸로 뒤집는 것이 좋고, 만약 알고리즘을 뒤집기 힘들다면, 파이썬 공식 라이브러리에서 제공하는 deque 같은 것을 써야 한다. [[자료구조]] 개념에 대한 감각이 있으면 이해하기 쉽다.\n CPython같은 경우 JIT를 쓰지 않기 때문에 이런 것을 자동으로 최적화 해 준다고 생각하지 말자.\n\n * 괄호 안에 for 과 if, else 를 넣을 시 주의하자. \n  {{{#!syntax python\n#1\nlist(x for x in range(10) if x%2 == 0)\n#2\nlist(x for x in range(10) if x%2 == 0 else 0)\n#3\nlist(x if x%2 == 0 else 0 for x in range(10))\n}}}\n  1은 되지만 2는 되지 않으며 3은 된다. if만 넣을 경우 for 뒤에 써야 하며, '''조건을 충족하지 않는 원소들은 생략된다'''(즉, 1의 결과물은 [0, 2, 4, 6, 8]이다). if와 else 모두를 넣는다면 for 앞에 넣어야 하며 조건을 충족하면 맨 앞, 아니라면 else 다음이 반환된다.\n\n * 마지막으로 호출된 값(대입이 이루어지지 않은 경우)은 '''_''' 변수에 저장된다. 또한 이 변수에 대입한 값은 버려진다.\n\n * 멀티프로세싱은 \\_\\_main\\_\\_ 블럭 안에 들어가야 한다. 네임스페이스 문제 때문. 들어가지 않으면 오류를 뿜는다.\n  {{{#!syntax python\n#if 대신 while도 가능.\nif __name__ == '__main__':\n}}}\n\n * 파이썬 2와 3에서의 range는 리턴 형식이 다르다. 2에서는 리스트를 리턴하지만 3에서는 range 객체를 리턴한다. 따라서 3에서 range를 리스트로 바꾸려면 아래와 같은 방법들로 전환해야 한다. 파이썬 2에 익숙한 사람은, 파이썬 3의 range는 파이썬 2의 xrange와 동일한 역할을 한다고 생각하면 된다.\n  {{{#!syntax python\nlist(range(10))\n[*range(10)]\n}}}\n  그 외에도 파이썬 2와 3은 정수 나눗셈, print 문법, 문자열 종류, import 방식 같은 데서 차이가 많이 나는 편이다. 일부는 {{{__future__}}}이라는 라이브러리에서 파이썬 2에서도 3과 같은 문법을 쓸 수 있도록 해 주는 기능을 제공하고 있지만, 그렇지 않은 부분들은 stack overflow등을 참고해서 직접 만들어서 쓰는 것이 좋다. 현재 많은 오픈 소스 라이브러리들이 {{{__future__}}}로 도배되어 있고 가내 수공업 식으로 호환성을 뗌질해 있는 것을 보면 말이다. 파이썬 2.7이 공식적으로 지원이 중단되면 시점까지 많은 라이브러리들이 파이썬 2 지원을 철회할 계획을 가지고 있으므로, 그 때가 되면 이런 호환성 문제에서 숨통이 트일 것이다.\n\n * [[http://freesugar.tistory.com/37|error: Microsoft Visual C++ 14.0 is required. Get it with \"Microsoft Visual C++ Build Tools\"]]\n\n * Bolierplate 코드가 적고, 리스트와 셋, 해시 등의 자료구조를 간단한 기호로 표기할 수 있어 코딩 테스트 시 많이 사용되는 언어이기도 하다. Python으로 코드를 작성하면 같은 알고리즘을 C++, Java 등으로 구현했을 때보다 전체적인 코드 길이가 비약적으로 짧아진다.\n\n * 파이썬 인터프리터라도 열어서 아무 모듈이나 임포트하거나, print 함수에 대해 dir(print)를 입력해보면 파이썬의 구조를 좀 더 잘 알게 된다. 우리가 사용했던 함수가 다르게 보일 것이다.\n\n== [[Python/문법|문법]] ==\n[include(틀:상세 내용, 문서명=Python/문법)]\n\n== 도서 ==\n파이썬은 [[2021년]] 현재까지도 '''이거다!''' 할 만한 명저가 없다. [[프로그래밍]] 입문부터 실사용까지 오만가지 책들이 난립해 있어서 핵심을 관통하는 주제를 딱히 잡기 어려워서인 듯 하다. (--사실 기본기와 개념만 제대로 익힌 다음에는 제일 배우기 쉬운 방법이 구글링이라 카더라.--)\n\n파이썬 관련 책은 대형 서점에 가면 파이썬 분류가 따로 잡혀서 어마어마하게 난립해 있을 정도로 경쟁이 치열하다. 파이썬만 따로 분류가 잡혀서 매대를 꽉 채운 파이썬 책들을 보다 보면 [[춘추전국시대]] 저리가라 할 수준이다. 그러나 도서들이 죄다 특정 분야에만 치중해서 전반적인 내용을 관통한 책은 별로 없는게 문제이다. [[Ruby]]같은 경우는 기타 프로그래밍 언어에 Programming Ruby 딱 한권만 달아놔도 재고가 없을 정도로 인기인 것과 정 반대. Python은 책이 워낙 많다보니 [[서점]]에도 재고가 수두룩하다. \n\n||<-2><tablewidth=25%> '''바로 쓰는 파이썬(기초편)''' ||\n||<width=100%> [[파일:바로 쓰는 파이썬.jpg|width=100%]] ||\n|| [[https://www.snupress.com/book/category?md=view&goodsidx=3069|관련 링크]] ||\n[[서울대학교]]의 일부 강좌에서 이번학기 학부 수업용 교재로 사용하기 시작하였다.\n\n||<-2><tablewidth=25%> '''Do It! 점프 투 파이썬''' ||\n||<width=100%> [[파일:x9788997390915.jpg|width=100%]] ||\n|| [[https://book.naver.com/bookdb/book_detail.nhn?bid=10290989|관련 링크]] ||\n[[대한민국]]에서 입문 서적으로는 위키독스에 연재된 강의를 편집한 [[https://book.naver.com/bookdb/book_detail.nhn?bid=10290989|Do It! 점프 투 파이썬]]이라는 서적이 인기가 많다. 컴퓨터 과학 부문 베스트셀러 수준. 기초적인 내용을 다루며 대상 독자도 비전문가라 매우 깊이 있는 책이라 보기는 어렵고 어디까지나 입문 서적이다. 그리고 [[한국]]에서만 인기가 있고, 점프 투 파이썬 정도의 '''입문서는 너무나도 많다'''. [[서점]]에 가면 매대에 깔린게 점프 투 파이썬 정도의 입문서들. 그러나 해당 책은 한국 국내에 커뮤니티가 형성([[네이버 카페]])되어 있어서 질문/답변이 빨라 [[베스트셀러]]에 올랐다. \n\n||<-2><tablewidth=50%> '''파이썬 쉽게, 더 쉽게''' ||\n||<width=50%> [[파일:1185890025_f.jpg|width=100%]] ||<width=50%> [[파일:x9791188621477.jpg|width=100%]] ||\n|| 2014년 판 || 2017년 개정판 ||\n또다른 입문서로는 [[일본]]에서 츠지 신고가 써서 나온 [[https://book.naver.com/bookdb/book_detail.nhn?bid=8109043|파이썬 더 쉽게, 더 깊게(원판)]] [[https://book.naver.com/bookdb/book_detail.nhn?bid=14364860|파이썬 쉽게, 더 쉽게(2017년 개정판)]]가 있다. 2014년 판은 Python 2 기준이고 2017년 판은 Python 3 기준이다. \n\nPython 입문을 벗어나고 나면, [[기계학습]] 분야로 갈 것이냐, [[빅데이터]] 분야로 갈 것이냐에 따라서 추천 도서가 달라진다. [[생활코딩]]에서도 이거 때문에 관련 문의가 [[페이스북]] 페이지에 올라오는 편이다.\n[[빅데이터]] 분야(데이터 분석 분야)로 가는 데에는 책이 많은데 학원 교재로는 [[https://book.naver.com/bookdb/book_detail.nhn?bid=12657786|파이썬 데이터 분석 입문: 엑셀 및 CSV 파일 처리부터 데이터베이스, 시각화, 통계분석, 자동화까지]]라는 책을 많이 쓴다. 이 분야에서 가장 많이 사용하는 Pandas 에만 집중하고 싶다면 Pandas 프로젝트를 시작한 웨스 맥키니(Wes Mckinney)가 저술한 '파이썬 라이브러리를 활용한 데이터 분석'으로 시작해도 좋다.\n\n||<-2><tablewidth=50%> '''밑바닥부터 시작하는 [[딥러닝]]''' ||\n||<width=50%> [[파일:91LOp7zilgL.jpg|width=100%]] ||<width=50%> [[파일:x9788968484636.jpg|width=100%]] ||\n|| [[https://www.amazon.co.jp/%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E4%BD%9C%E3%82%8BDeep-Learning-%E2%80%95Python%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%A3%E3%83%BC%E3%83%97%E3%83%A9%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%AE%E7%90%86%E8%AB%96%E3%81%A8%E5%AE%9F%E8%A3%85-%E6%96%8E%E8%97%A4-%E5%BA%B7%E6%AF%85/dp/4873117585|일본 원서]] || [[https://book.naver.com/bookdb/book_detail.nhn?bid=11492334|한국어 번역서]] ||\nPython [[기계학습]] [[딥러닝]] 분야만큼은 명저가 하나 나왔다. 일본의 사이토 고키가 쓴 \"밑바닥부터 시작하는 딥러닝\"이라는 책이다. 원서 [[일본어]]로 나왔는데, 일본 내에서 사이토 고키가 직접 감수를 맡은 [[영어]]판이 같이 나와 이 영어판을 기반으로 [[미국]]에서 인기를 끌었다. 그리고 [[2016년]] [[구글 딥마인드 챌린지 매치]]로 [[인공지능]] 분야가 한국 일반인에게 알려지면서 해당 도서가 [[2017년]] [[한국어]]로 번역 출간되었다. 번역 질도 굉장히 깔끔해서 보기 좋다. 결정적으로 책이 두껍지 않고 얇다. [[얇은 책]]인데 핵심만 집어넣어서 이론을 완성해가지고 대통일 명저로 꼽힌다. \n\n[[한국]] 국내에서 [[주식]] [[투자]]를 하는 사람 중에서 이른바 [[알고리즘 트레이딩]], 쉽게말해 개인판 [[프로그램 매매]][* [[프로그램 매매]]는 동시에 5억 원 이상의 매매를 내는 거래로, 원래는 [[한국예탁결제원]]의 승인을 받은 [[기관]] 투자자나 [[외국인]] 투자자만 사전에 예탁결제원에 프로그램을 등록하고 매매할 수 있다. 그런데 동시에 5억원 미만의 거래를 하는 개인투자자들까지 예탁결제원이 간섭하기는 뭐했는지 이쪽은 규제 사각지대다.]를 짜려는 사람도 있다. 이런 사람들은 [[https://book.naver.com/bookdb/book_detail.nhn?bid=14623546|파이썬으로 배우는 알고리즘 트레이딩]]이라는 책이 인기가 좋다. [[한국]] [[개미]]투자자들이 주로 사용하는 [[키움증권]], [[미래에셋대우]], [[이베스트투자증권]], [[대신증권]] API를 활용해, 간단한 프로그램을 짜서 프로그램 매매를 할 수 있기 때문이다. 원래 Python 속도가 느려서 원래 알고리즘 트레이딩(개인 프로그램 매매)는 Python보다 속도가 빠른 [[R(프로그래밍 언어)|R]]이나 [[C언어]]로 하는게 원칙이다. [[미국]] [[금융]]업계에서는 R로 하는 프로그램 매매를 가르친다.[* [[일본]]은 [[Ruby]]가 대세라서, Ruby로 하는 [[알고리즘 트레이딩]]이 많다. Ruby로 만든 트레이딩 툴은 Python과 비슷한 퍼포먼스가 난다.] 그런데 한국에서는 주식 투자자들 보고 Python 외에 R이나 [[C언어]]까지 배우라고 하기는 어렵다고 생각했는지, Python 알고리즘 트레이딩 책이 나왔다. 해당 책은 [[2017년]] 나온 이후 인기를 끌어서 [[2019년]] 개정판이 나올 정도가 됐다.\n\n||<-2><tablewidth=25%> '''파이썬 알고리즘 인터뷰''' ||\n||<width=100%> [[파일:pai_cover.jpg|width=100%]] ||\n|| [[https://book.naver.com/bookdb/book_detail.nhn?bid=16406247|관련 링크]] ||\nPython으로 알고리즘 문제를 풀이하는 책도 나와 있다. 과거에는 알고리즘 대회나 코딩 테스트시 C++을 주로 사용해왔으나 직관적이고 쉬운 문법으로 인해 Python이 점점 인기를 얻고 있다. 이 책은 국내 첫 출간된 Python 알고리즘 코딩 테스트 책으로 자료구조와 알고리즘을 그림으로 도식화해 이해하기 쉽게 설명하고, 카카오 코딩 테스트 기출 문제 포함 주제별 다양한 알고리즘 코딩 테스트 문제를 다양한 각도에서 효율적인 방식으로 풀이하여 좋은 반응을 얻고 있다. 나무위키 또한 이 책에서 사용을 허락한 일러스트를 이용해 다양한 알고리즘을 효과적으로 설명하고 있다.\n\n== 여담 ==\n * [[구글]]에서 python이라고 검색하면 제일 위에 뜨는 게 바다 괴물이나 [[파이톤#s-1|뱀]]이 아니라 이거다.\n\n * [[pyBreakout]]이라는 게임은 파이썬으로만 작성되었다. 오로지 pygame만 사용했으며, 개발자가 초등학생이다.\n\n * Python의 공식 documentation은 정말 형편없기로 유명하다. 구체적으로는 직관성이 떨어지고 예시가 부실한 것이 그 이유인데, 꼭 필요할 때 읽으려면 헤매기 십상이다. 심지어 이는 국내도 아닌 영어가 모국어인 프로그래머들의 공론인데, Python을 찬양하는 프로그래머들도 인정하는 부분이다. 다만 최신 버전으로 갈수록 가독성이 조금씩 개선되어 가고 있다.\n\n * Google Android OS에서는 공식적으로 Python을 미지원한다. 하지만 SL4A나 Linux Emulator를 설치 후 Python 실행이 가능하다.[[https://kibua20.tistory.com/117|비교내용]]\n\n * 만약 파이썬으로 짠 코드가 잘 작동되는 것을 넘어 가독성이 높고 유지보수도 쉬운 코드라면 이를 파이썬다운(pythonic, 파이써닉) 코드라며 대우한다. 일반 프로그래머라면 이러한 파이써닉 코드를 지향해야 한다.\n\n * [[띵소프트]]에서 개발 중인 게임 [[페리아 연대기]]에서는 '''고대언어'''라고 한다.\n\n * [[https://plus.google.com/115212051037621986145/posts/R8jEVrobbRj|2013년 재미있게도 한 헤드헌터로부터 경력직 파이썬 개발자 취업제안을 받았다고 한다.]] 즉, '''파이썬 창시자에게 파이썬 '경력직' 개발자를 구하는 수준의 메일을 보낸 것'''.\n\n * [[C++]], [[Java]]와 함께 [[구글]]의 3대 개발 언어 중 하나로 알려져 있다.\n\n * [[문명 4]]의 스크립트 언어로 쓰였다. [[Lua]]와 더불어 게임 스크립트 언어의 양대 산맥.\n\n * [[심즈 4]] 역시 Python을 기반으로 해서 동작한다. 클라이언트를 살짝 보면 수많은 .pyo 파일들의 향연을 볼 수 있다. 심즈 4의 최적화는 나름 우수한 편. 근데 pyo가 3.5 버전에서 삭제되고 pyc로 대체되었다.\n\n * [[킹덤 언더 파이어]]의 엔진에도 쓰였다. 500여 개의 자체모듈이 누더기처럼 돌아갔다고 한다.\n\n * [[월드 오브 탱크]]는 상당 부분이 파이썬으로 구현되어있다. 유저가 작성하는 모드도 로직 부분은 파이썬으로 구현된다.\n\n * [[EVE 온라인]]은 Python의 경량/고속 실행 버전인 Stackless Python으로 작성되었다. 개발사 CCP Games는 파이썬 재단의 정식 후원자이기도 하다. 2000년대 초에 싱글코어 CPU가 계속 쓰일 줄 알고 서버 코드를 구버전 파이썬으로 짰다가 다중 코어 사용이 힘들어지자[* 전장에서 일어나는 일을 제외한 나머지 시시콜콜한 일을 다른 코어로 돌리기는 하였으나, 게임의 최소 단위인 전장은 구조상의 한계로 하나의 코어만 동원할 수 있다.] 눈물겨운 마개조를 거듭하여 파이썬이라는 언어가 제공할 수 있는 처리 능력을 한계치까지 뽑아서 쓰고 있다.\n\n * [[https://www.pythonpad.co/courses/intro-1/|파이썬패드 프로그래밍 기초 강의]]. 카이스트 프로그래밍 기초 과목과 호환되는 공개 강의이다. 인터프리터 설치 없이 기초적인 파이썬 사용법을 배울 수 있다.\n\n * [[https://codecombat.com|코드컴뱃 홈페이지]]. 파이썬을 게임의 형식을 빌려 배울 수 있는 사이트이다.\n\n * [[http://www.numpy.org/|NumPy]]+[[http://www.scipy.org/|SciPy]]+[[http://matplotlib.org/|matplotlib]] 조합이 과학 공학 계산용으로 자주 쓰인다.\n\n * [[파일:external/regmedia.co.uk/swift_benchmark.jpg]]\n 2014년 6월 WWDC에서 애플이 공개한 프로그래밍 언어 [[Swift(프로그래밍 언어)|Swift]]보다 220배 느리다고 까였다. 유저들은 [[C(프로그래밍 언어)|C]] 바인딩인 ctypes를 출동 시킨다고 부들부들... '''하지만 [[JIT]] 없는 동적 인터프리터 언어와 컴파일 언어의 성능을 비교하면 어떤 언어를 비교하더라도 당연히 후자가 압도적으로 유리하다는 점에서 이건 비교 자체가 잘못된 것이다.''' 게다가 암호화 같은 CPU heavy한 작업은 보통 다 C로 짜서 붙인다. Python 해쉬 라이브러리인 hashlib만 해도 코어가 전부 C로 되어있다.\n\n * [[객체 지향 프로그래밍]]을 배울 때 추천할 만한 언어이다. 많은 대학들이 [[C++]] 환경에서 OOP를 가르치지만, 이 경우 필요한 객체를 만들어서 쓰는 실습이 많은데 대부분 이미 존재하는 객체를 가져다 쓴다는 개념을 이해하지 못하는 경우가 많다. STL을 쓰면 달라지지만 실습에서 STL을 요구하는 문제가 나오는 경우도 드물고, 주로 사용되는 문자열 변환, 배열 관련 연산 등은 파이썬에서 따로 임포트할 필요 없이 자료형 자체가 이미 클래스로서 편리하게 클래스 함수를 던져주기 때문에, 클래스의 재활용이라는 측면을 훨씬 이해하기 쉽다. 무엇보다 하루면 다 배울 수 있는 언어이기도 하고. 다만 대학들도 아무런 이유 없이 C++을 객체 지향 입문용으로 채택한 건 아니다. 많은 학생들이 프로그래밍 언어 중 C를 가장 먼저 배우기에, C++은 그나마 익숙한 개념들을 이용해서 객체 지향을 학습할 수 있게 한다. 물론 C++ 프로그래밍은 C 프로그래밍과는 패러다임 자체가 다르므로 주의가 필요하지만, 적어도 \"[[C언어]]의 [[구조체]] 안에 함수를 정의할 수 있게 하면 C++이다\"는 식의 낚시로 학생들에게 심리적 편안함을 줄 수는 있다. 최근에는 객체 지향 입문용 언어로 C++보다 파이썬을 먼저 가르치는 대학도 늘어나고 있는 추세라, 파이썬부터 먼저 공부하는 것도 나쁘지 않다.\n  * Fluent Python(번역서: 전문가를 위한 파이썬)이라는 책이 있다.\n\n * [[https://doc.lagout.org/programmation/python/Data%20Structures%20and%20Algorithms%20in%20Python%20%5BGoodrich%2C%20Tamassia%20%26%20Goldwasser%202013-03-18%5D.pdf|알고리즘 및 자료구조를 파이썬]]으로 공부하기\n\n * [[2014년]] 8월 30일, 유서깊은 파이썬행사인 PyCon이 드디어 한국에서도 성공리에 개최되었다. [[http://pycon.kr/2014|#공식홈페이지]]\n [[2015년]] 8월 29일, PyCon 2015가 [[상암]] 누리꿈스퀘어에서 약 700명의 규모로 개최되었다. [[http://pycon.kr/2015|#공식홈페이지]]\n [[2016년]]에는 PyCon APAC가 [[한국]]에서[* 강남 코엑스에서 13~14일 아카마이에서 15일(튜토리얼).] 성공리에 개최되었다.[[https://www.pycon.kr/2016apac/|#공식홈페이지]]\n [[2017년]]에는 PyCon.KR 2017(파이콘 한국 2017)이 강남 [[코엑스]]에서 열렸다(8.12~15).\n [[2018년]]에는 PyCon.KR에 참가한 [[IntelliJ IDEA]]로 유명한 [[JetBrains]]의 [[PyCharm]] 프로젝트 매니저인 Dmitry Trofimov가 행사를 보고 [[https://github.com/traff/pycharm-kr|PyCharm 한글화 오픈소스 프로젝트]]를 열었다. 그러나 번역이 20% 정도 되고 수 년째 멈춰 있는 상태...관심있는 사람들은 기여해 보자. 다만 개발자들은 호환성을 위해서 영어 버전을 사용하는 경우가 대부분이라 기여를 할 사람이 있을지는 의문이다.\n\n * 2015년 7월 9일 \"같이 번역해서 같이 봅시다\"라는 표어를 내걸고 파이썬 문서를 '''한글로 번역하는''' 프로젝트가 생겼다. [[http://www.flowdas.com/pages/python-docs-ko.html|flowdas / 파이썬 한국어 번역]]\n\n * [[도널드 글로버]]가 자신의 노래 가사에 Python을 배우라는 가사를 넣기도 했다.\n\n * [[타오바오]]에서 [[https://npm.taobao.org/mirrors/python/|다운로드 미러]]를 제공하고 있다.\n\n * 귀도 반 로섬은 2019년 10월 30일부로 [[드랍박스]]에서 나오고 은퇴하였다.\n\n * 그리고 2020년 11월 13일, 은퇴 생활이 지루하다며 다시 [[마이크로소프트]] 의 개발팀에 합류했다. [* [[https://twitter.com/gvanrossum/status/1326932991566700549|트윗]] ]\n\n * [[디시인사이드]] [[마이너 갤러리]] 중 [[https://gall.dcinside.com/python|파이썬 마이너 갤러리]]가 있었으나 접근 제한 조치되어 [[아카라이브]] [[https://arca.live/b/python|파이썬 채널]]로 이주하였다.\n\n * 3.5부터는 XP를 지원하지 않는다. \n\n *  [[투어라이브 ]]의 백엔드 기술의  대부분은 파이썬으로 구현되어있다.  \n\n * 2020년 5월, 3.9부터는 비스타와 7을 지원하지 않는다.\n\n[[분류:Python]]",
    "contributors": [
        "203.241.183.12",
        "wikior",
        "39.119.129.24",
        "cksgh9103",
        "lallasweet",
        "lifeeraser",
        "210.101.187.205",
        "wtousim",
        "benquan1812",
        "61.254.37.240",
        "113.59.178.10",
        "piingn",
        "121.125.172.41",
        "122.44.174.52",
        "seacrest",
        "depth",
        "14.41.41.91",
        "halfling",
        "211.185.250.158",
        "dbstjd56599",
        "1.229.188.147",
        "125.181.58.208",
        "lesmeasurables",
        "zoroark571",
        "rafina227",
        "211.223.35.76",
        "chcv",
        "archevil",
        "223.222.170.133",
        "jjin3826",
        "210.121.232.120",
        "kkkyyy03",
        "175.123.58.63",
        "112.171.89.167",
        "pistol",
        "121.127.84.205",
        "detegice",
        "chiantiscarlett",
        "arduino",
        "203.251.29.244",
        "ddssz033",
        "218.239.156.125",
        "124.50.97.25",
        "175.197.4.193",
        "220.71.126.100",
        "gyumin202",
        "175.119.80.41",
        "211.170.11.154",
        "superman",
        "117.123.13.121",
        "aninteger",
        "hanzaixing",
        "notebox9245",
        "ninanyong",
        "121.161.88.13",
        "14.46.222.205",
        "222.107.66.182",
        "hoonnam",
        "damena_inazuma",
        "iz7h",
        "syntax0",
        "fred6758",
        "126.15.241.156",
        "203.234.243.93",
        "125.142.252.250",
        "116.125.117.239",
        "chaneyoon",
        "myweet",
        "210.207.20.50",
        "64.233.173.226",
        "175.127.179.215",
        "jason2357y",
        "116.127.137.127",
        "211.196.191.136",
        "14.32.105.91",
        "112.156.240.224",
        "blackj0221",
        "hyphen",
        "64.180.168.141",
        "118.217.34.111",
        "14.42.39.82",
        "121.137.63.56",
        "qurate5031",
        "bglassm",
        "112.171.19.10",
        "alfalfa",
        "mangal",
        "secon",
        "121.138.88.245",
        "minikupa",
        "121.187.207.51",
        "southsea6",
        "121.155.143.136",
        "58.126.228.82",
        "59.7.246.12",
        "180.229.33.234",
        "211.252.20.97",
        "r:pckdrms",
        "monoasterisk",
        "175.125.25.60",
        "124.80.40.167",
        "khb",
        "49.50.0.194",
        "14.54.24.2",
        "220.85.177.8",
        "sju07144",
        "122.44.177.108",
        "gusaka213",
        "pirunhd",
        "jjikkses",
        "zweihaender",
        "suplexhold",
        "211.199.35.44",
        "miroo4517",
        "219.250.138.110",
        "183.97.197.160",
        "kanaraten",
        "59.19.188.186",
        "121.141.115.10",
        "namsan",
        "119.203.247.119",
        "121.129.97.167",
        "110.11.76.84",
        "218.39.116.97",
        "great_red",
        "45.115.65.100",
        "kerrigan",
        "rambor12",
        "125.177.122.42",
        "112.109.62.176",
        "58.120.205.181",
        "210.108.251.60",
        "kpjhg0124",
        "182.230.208.229",
        "gusunbark",
        "diddnjswns07",
        "121.162.51.10",
        "1.252.23.30",
        "libro",
        "pppp",
        "jjangsepd",
        "125.183.95.237",
        "sangh518",
        "175.194.45.196",
        "doubleplus",
        "mapirus",
        "e080hsm",
        "kongkongduri",
        "1.251.244.192",
        "175.116.127.44",
        "121.179.17.200",
        "fairy",
        "60.253.6.80",
        "vincent525",
        "58.29.38.128",
        "picachu2333",
        "61.75.146.155",
        "rudiblaz",
        "142.147.59.203",
        "heffykuma",
        "king0816",
        "mungyu",
        "106.242.15.210",
        "ldmsys",
        "albert_einstein",
        "142.105.55.123",
        "210.90.249.160",
        "rladbqls1",
        "nonnonapp",
        "winster77",
        "democraz",
        "sincity",
        "sequentialaccess",
        "rqme20",
        "112.170.60.253",
        "simonfly05",
        "121.138.83.21",
        "211.219.104.85",
        "162.222.168.66",
        "211.252.95.147",
        "121.167.209.189",
        "hks01108",
        "175.197.32.54",
        "1.210.0.80",
        "kimsu21",
        "otimtim",
        "210.117.181.205",
        "prime235711",
        "one",
        "yerel",
        "caenhon",
        "112.172.211.218",
        "221.155.89.188",
        "222.65.189.224",
        "211.209.249.63",
        "finefain",
        "sylee957",
        "jebi",
        "118.217.134.214",
        "59.10.206.166",
        "116.122.87.8",
        "avantgarde95",
        "owb101",
        "user0320",
        "222.120.77.100",
        "sm5good1234",
        "agenti",
        "221.155.195.238",
        "ztarqwe",
        "nancykwon",
        "175.192.173.207",
        "14.45.91.209",
        "39.116.141.238",
        "118.176.119.138",
        "seungwoo208",
        "124.80.44.22",
        "louise0404",
        "anatra95",
        "118.36.189.201",
        "121.157.194.44",
        "118.219.105.8",
        "ik1ne",
        "112.156.2.91",
        "210.179.98.189",
        "myanonnw",
        "kazuya0227",
        "73.9.103.38",
        "223.62.169.8",
        "121.127.84.236",
        "loked",
        "14.39.24.173",
        "jibril_lee",
        "natreebin",
        "zrwgy",
        "daressalaam",
        "211.106.189.139",
        "211.247.73.132",
        "219.254.86.110",
        "centercho",
        "115.139.63.189",
        "kibua20",
        "mechartist",
        "117.111.14.62",
        "ysggun",
        "115.140.219.171",
        "kaizer1028",
        "121.130.81.191",
        "1.249.134.85",
        "lht1324",
        "220.89.64.229",
        "secwind",
        "tripleh147",
        "r:daze3819",
        "122.36.104.189",
        "210.138.208.41",
        "pseudojo",
        "awesome",
        "61.74.89.239",
        "r:asdefary",
        "hided",
        "39.7.56.74",
        "angelbot",
        "211.52.193.38",
        "119.194.212.13",
        "dogyun0906",
        "1.238.216.12",
        "mswgen",
        "118.34.181.214",
        "carlos",
        "182.227.60.100",
        "116.42.180.231",
        "jhseo1107",
        "117.123.33.154",
        "116.67.26.128",
        "xhaser",
        "rbalsdldi",
        "youngplus31",
        "222.101.105.135",
        "211.219.154.133",
        "2du",
        "123.215.30.152",
        "jinski",
        "121.169.34.38",
        "prozect",
        "r:cbq",
        "41.73.7.108",
        "drod7429",
        "lulin_pollux",
        "119.202.86.70",
        "95.130.9.89",
        "182.221.33.142",
        "drago777",
        "genic",
        "221.151.251.185",
        "24.66.178.27",
        "118.34.159.136",
        "122.44.162.131",
        "165.132.144.164",
        "112.160.104.90",
        "murtin",
        "makerj",
        "58.236.166.34",
        "nargronus",
        "175.127.108.99",
        "crommune",
        "220.93.130.63",
        "say8425",
        "126.22.52.172",
        "210.178.183.175",
        "119.70.151.150",
        "125.135.167.145",
        "dontsaymyid",
        "hoya",
        "203.104.128.125",
        "222.232.180.49",
        "gyeonsil",
        "123.143.54.70",
        "58.228.56.97",
        "dlfwkflq",
        "accessable",
        "archshootr",
        "27.122.242.76",
        "173.70.53.126",
        "zeplin_y",
        "128.134.102.49",
        "112.161.64.225",
        "kghnkl0103",
        "175.212.99.237",
        "ranoma",
        "220.89.5.75",
        "175.121.118.43",
        "121.161.89.25",
        "222.100.64.108",
        "ruukkge",
        "nnsyc4906",
        "raon917",
        "125.179.238.97",
        "sura148",
        "hoejin88",
        "114.200.49.161",
        "222.120.77.154",
        "175.113.90.137",
        "125.142.117.68",
        "imaginedragoons",
        "175.201.166.127",
        "130.245.207.43",
        "61.72.95.133",
        "science",
        "kbumsik",
        "168.126.6.84",
        "211.223.188.220",
        "ssut",
        "kiwitree2",
        "bomoung79",
        "121.134.119.26",
        "183.97.197.41",
        "grakham",
        "118.175.155.156",
        "183.101.131.246",
        "namubot",
        "182.221.71.208",
        "211.209.90.163",
        "dhkim0800",
        "39.115.23.2",
        "66.249.82.244",
        "118.221.101.119",
        "nuerburgring",
        "61.75.27.205",
        "116.39.112.57",
        "14.46.253.39",
        "a3963409",
        "115.126.243.244",
        "112.154.54.156",
        "freaxtux",
        "hyunmyu",
        "kiwitree",
        "opskos",
        "58.120.75.105",
        "oc819",
        "godeer",
        "nasa010",
        "175.199.216.215",
        "harry9939",
        "14.32.45.90",
        "59.17.245.59",
        "int",
        "211.217.122.170",
        "rtyu1120",
        "183.96.134.33",
        "121.64.201.163",
        "ssangmun2",
        "61.102.73.205",
        "sizzflair97",
        "jaepilnim",
        "49.169.136.74",
        "125.132.199.173",
        "222.112.33.74",
        "221.155.149.49",
        "39.118.136.74",
        "kemo",
        "210.0.41.65",
        "47.23.149.58",
        "musoftware",
        "211.247.111.100",
        "117.16.196.138",
        "124.54.119.44",
        "210.222.42.158",
        "bluefairy",
        "konan8205",
        "simple0925",
        "116.120.166.236",
        "166.104.144.171",
        "124.55.8.72",
        "175.118.200.137",
        "jimmy1223",
        "royleejr",
        "piousness554",
        "sdynet",
        "samduk",
        "110.14.225.174",
        "membership20",
        "1.242.112.218",
        "121.168.139.226",
        "180.81.65.111",
        "dmscks2015",
        "175.121.118.83",
        "revery",
        "lgp5859",
        "meatloaf",
        "143.248.32.198",
        "1.251.62.6",
        "railgun",
        "wrsohn07",
        "1.227.231.196",
        "1.231.83.102",
        "49.50.0.178",
        "myh2910",
        "likejazz",
        "70.187.179.99",
        "183.107.37.56",
        "218.237.156.159"
    ]
}
